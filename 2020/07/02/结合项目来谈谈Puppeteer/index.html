<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>结合项目来谈谈 Puppeteer | 自强不息</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Puppeteer 是 Chrome 开发团队在 2017 年发布的一个 Node.js 包，用来模拟 Chrome 浏览器的运行。我们团队从 Puppeteer 刚发布出来就开始成为忠实用户了（主要是因为 PhantomJs 坑太多了），本文主要在介绍 Puppeteer 的同时，结合我们平时的实践做一个分享。">
<meta property="og:type" content="article">
<meta property="og:title" content="结合项目来谈谈 Puppeteer">
<meta property="og:url" content="http://moqiang02.github.io/2020/07/02/%E7%BB%93%E5%90%88%E9%A1%B9%E7%9B%AE%E6%9D%A5%E8%B0%88%E8%B0%88Puppeteer/index.html">
<meta property="og:site_name" content="自强不息">
<meta property="og:description" content="Puppeteer 是 Chrome 开发团队在 2017 年发布的一个 Node.js 包，用来模拟 Chrome 浏览器的运行。我们团队从 Puppeteer 刚发布出来就开始成为忠实用户了（主要是因为 PhantomJs 坑太多了），本文主要在介绍 Puppeteer 的同时，结合我们平时的实践做一个分享。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://moqiang02.github.io/images/%E7%BB%93%E5%90%88%E9%A1%B9%E7%9B%AE%E6%9D%A5%E8%B0%88%E8%B0%88_Puppeteer/1.png">
<meta property="og:image" content="http://moqiang02.github.io/images/%E7%BB%93%E5%90%88%E9%A1%B9%E7%9B%AE%E6%9D%A5%E8%B0%88%E8%B0%88_Puppeteer/2.jpg">
<meta property="og:image" content="http://moqiang02.github.io/images/%E7%BB%93%E5%90%88%E9%A1%B9%E7%9B%AE%E6%9D%A5%E8%B0%88%E8%B0%88_Puppeteer/3.jpg">
<meta property="og:image" content="http://moqiang02.github.io/images/%E7%BB%93%E5%90%88%E9%A1%B9%E7%9B%AE%E6%9D%A5%E8%B0%88%E8%B0%88_Puppeteer/4.jpg">
<meta property="article:published_time" content="2020-07-01T16:09:15.000Z">
<meta property="article:modified_time" content="2022-10-26T09:28:54.165Z">
<meta property="article:author" content="moqiang">
<meta property="article:tag" content="爬虫">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://moqiang02.github.io/images/%E7%BB%93%E5%90%88%E9%A1%B9%E7%9B%AE%E6%9D%A5%E8%B0%88%E8%B0%88_Puppeteer/1.png">
  
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">自强不息</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://moqiang02.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-结合项目来谈谈Puppeteer" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/07/02/%E7%BB%93%E5%90%88%E9%A1%B9%E7%9B%AE%E6%9D%A5%E8%B0%88%E8%B0%88Puppeteer/" class="article-date">
  <time class="dt-published" datetime="2020-07-01T16:09:15.000Z" itemprop="datePublished">2020-07-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/nodejs/">nodejs</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      结合项目来谈谈 Puppeteer
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      

          <!-- rex -->
          
            <!-- 文章目录开始 -->
            
              <div id="toc" class="toc-article">
              <strong class="toc-title" style="cursor:pointer">目录</strong>
              <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Chrome-DevTool-Protocol"><span class="toc-number">1.</span> <span class="toc-text">什么是 Chrome DevTool Protocol</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Headless-Chrome"><span class="toc-number">2.</span> <span class="toc-text">什么是 Headless Chrome</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Puppeteer-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">3.</span> <span class="toc-text">Puppeteer 是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Puppeteer-%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88"><span class="toc-number">4.</span> <span class="toc-text">Puppeteer 能做什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Puppeteer-API-%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-number">5.</span> <span class="toc-text">Puppeteer API 分层结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA-Browser-%E5%AE%9E%E4%BE%8B"><span class="toc-number">6.</span> <span class="toc-text">如何创建一个 Browser 实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%AD%89%E5%BE%85%E5%8A%A0%E8%BD%BD%EF%BC%9F"><span class="toc-number">7.</span> <span class="toc-text">如何等待加载？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E5%AF%BC%E8%88%AA%E9%A1%B5%E9%9D%A2"><span class="toc-number">7.1.</span> <span class="toc-text">加载导航页面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E5%85%83%E7%B4%A0%E3%80%81%E8%AF%B7%E6%B1%82%E3%80%81%E5%93%8D%E5%BA%94"><span class="toc-number">7.2.</span> <span class="toc-text">等待元素、请求、响应</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AD%89%E5%BE%85"><span class="toc-number">7.3.</span> <span class="toc-text">自定义等待</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E7%8B%AC%E7%AB%8B%E7%9A%84%E7%8E%AF%E5%A2%83"><span class="toc-number">8.</span> <span class="toc-text">两个独立的环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E4%B8%AA%E7%94%A8%E4%BE%8B%E5%91%8A%E8%AF%89%E4%BD%A0%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-puppeteer"><span class="toc-number">9.</span> <span class="toc-text">10 个用例告诉你如何使用 puppeteer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Case1%EF%BC%9A%E6%88%AA%E5%9B%BE"><span class="toc-number">9.1.</span> <span class="toc-text">Case1：截图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#case2-%E6%A8%A1%E6%8B%9F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95"><span class="toc-number">9.2.</span> <span class="toc-text">case2: 模拟用户登录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#case3%EF%BC%9A%E8%AF%B7%E6%B1%82%E6%8B%A6%E6%88%AA"><span class="toc-number">9.3.</span> <span class="toc-text">case3：请求拦截</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#case4%EF%BC%9A%E8%8E%B7%E5%8F%96-WebSocket-%E5%93%8D%E5%BA%94"><span class="toc-number">9.4.</span> <span class="toc-text">case4：获取 WebSocket 响应</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#case5%EF%BC%9A%E6%A4%8D%E5%85%A5-javascript-%E4%BB%A3%E7%A0%81"><span class="toc-number">9.5.</span> <span class="toc-text">case5：植入 javascript 代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#case6-%E5%A6%82%E4%BD%95%E6%8A%93%E5%8F%96-iframe-%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">9.6.</span> <span class="toc-text">case6: 如何抓取 iframe 中的元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#case7-%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">9.7.</span> <span class="toc-text">case7: 页面性能分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#case8-%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD"><span class="toc-number">9.8.</span> <span class="toc-text">case8: 文件的上传和下载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#case9%EF%BC%9A%E8%B7%B3%E8%BD%AC%E6%96%B0-tab-%E9%A1%B5%E5%A4%84%E7%90%86"><span class="toc-number">9.9.</span> <span class="toc-text">case9：跳转新 tab 页处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#case10-%E6%A8%A1%E6%8B%9F%E4%B8%8D%E5%90%8C%E7%9A%84%E8%AE%BE%E5%A4%87"><span class="toc-number">9.10.</span> <span class="toc-text">case10: 模拟不同的设备</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Puppeteer-vs-Phantomjs"><span class="toc-number">10.</span> <span class="toc-text">Puppeteer vs Phantomjs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Puppeteer-%E5%9C%A8%E6%88%91%E4%BB%AC%E5%9B%A2%E9%98%9F%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">11.</span> <span class="toc-text">Puppeteer 在我们团队的应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%92%8C%E4%BC%98%E5%8C%96"><span class="toc-number">12.</span> <span class="toc-text">性能和优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="toc-number">13.</span> <span class="toc-text">参考文献</span></a></li></ol>
              </div>
            
            <!-- 文章目录结束 -->	  
          

        <p>Puppeteer 是 Chrome 开发团队在 2017 年发布的一个 Node.js 包，用来模拟 Chrome 浏览器的运行。我们团队从 Puppeteer 刚发布出来就开始成为忠实用户了（主要是因为 PhantomJs 坑太多了），本文主要在介绍 Puppeteer 的同时，结合我们平时的实践做一个分享。<span id="more"></span></p>
<p>学习 Puppeteer 之前我们先来了解一下 Chrome DevTool Protocol</p>
<h3 id="什么是-Chrome-DevTool-Protocol"><a href="#什么是-Chrome-DevTool-Protocol" class="headerlink" title="什么是 Chrome DevTool Protocol"></a><a href="https://link.zhihu.com/?target=https://chromedevtools.github.io/devtools-protocol/">什么是 Chrome DevTool Protocol</a></h3><ul>
<li>  CDP 基于 WebSocket，利用 WebSocket 实现与浏览器内核的快速数据通道</li>
<li>  CDP 分为多个域（DOM，Debugger，Network，Profiler，Console…），每个域中都定义了相关的命令和事件（Commands and Events）</li>
<li>  我们可以基于 CDP 封装一些工具对 Chrome 浏览器进行调试及分析，比如我们常用的 “Chrome 开发者工具” 就是基于 CDP 实现的</li>
<li>  如果你以 remote-debugging-port 参数启动 Chrome，那么就可以看到所有 Tab 页面的开发者调试前端页面，还会在同一端口上还提供了 http 服务，主要提供以下几个接口：</li>
</ul>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /json/version                     <span class="comment"># 获取浏览器的一些元信息</span></span><br><span class="line">GET /json or /json/list               <span class="comment"># 当前浏览器上打开的一些页面信息</span></span><br><span class="line">GET /json/protocol                    <span class="comment"># 获取当前 CDP 的协议信息</span></span><br><span class="line">GET /json/new?&#123;url&#125;                   <span class="comment"># 开启一共新的 Tab 页面</span></span><br><span class="line">GET /json/activate/&#123;targetId&#125;         <span class="comment"># 激活某个页面成为当前显示的页面</span></span><br><span class="line">GET /json/close/&#123;targetId&#125;            <span class="comment"># 关闭某个页面</span></span><br><span class="line">GET /devtools/inspector.html          <span class="comment"># 打开当前页面的开发者调试工具</span></span><br><span class="line">WebSocket /devtools/page/&#123;targetId&#125;   <span class="comment"># 获取某个页面的 websocket 地址</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  很多有用的工具都是基于 CDP 实现的，比如 <a href="https://link.zhihu.com/?target=https://developers.google.cn/web/tools/chrome-devtools/">Chrome 开发者工具</a>，<a href="https://link.zhihu.com/?target=https://github.com/cyrus-and/chrome-remote-interface">chrome-remote-interface</a>，<a href="https://link.zhihu.com/?target=https://github.com/GoogleChrome/puppeteer/">Puppeteer</a> 等</li>
</ul>
<h3 id="什么是-Headless-Chrome"><a href="#什么是-Headless-Chrome" class="headerlink" title="什么是 Headless Chrome"></a>什么是 Headless Chrome</h3><ul>
<li>  在无界面的环境中运行 Chrome</li>
<li>  通过命令行或者程序语言操作 Chrome</li>
<li>  无需人的干预，运行更稳定</li>
<li>  在启动 Chrome 时添加参数 --headless，便可以 headless 模式启动 Chrome</li>
</ul>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alias <span class="attr">chrome</span>=<span class="string">&quot;/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome&quot;</span>  <span class="comment"># Mac OS X 命令别名</span></span><br><span class="line">chrome --headless <span class="attr">--remote-debugging-port</span>=<span class="number">9222</span> --disable-gpu                   <span class="comment"># 开启远程调试</span></span><br><span class="line">chrome --headless --disable-gpu --dump-dom https://www.baidu.com               <span class="comment"># 获取页面 DOM</span></span><br><span class="line">chrome --headless --disable-gpu --screenshot https://www.baidu.com             <span class="comment"># 截图</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  chrome 启动时可以加一些什么参数，大家可以点击<a href="https://link.zhihu.com/?target=https://peter.sh/experiments/chromium-command-line-switches/">这里</a>查看</li>
</ul>
<h3 id="Puppeteer-是什么"><a href="#Puppeteer-是什么" class="headerlink" title="Puppeteer 是什么"></a>Puppeteer 是什么</h3><ul>
<li>  Puppeteer 是 Node.js 工具引擎</li>
<li>  Puppeteer 提供了一系列 API，通过 Chrome DevTools Protocol 协议控制 Chromium/Chrome 浏览器的行为</li>
<li>  Puppeteer 默认情况下是以 headless 启动 Chrome 的，也可以通过参数控制启动有界面的 Chrome</li>
<li>  Puppeteer 默认绑定最新的 Chromium 版本，也可以自己设置不同版本的绑定</li>
<li>  Puppeteer 让我们不需要了解太多的底层 CDP 协议实现与浏览器的通信</li>
</ul>
<h3 id="Puppeteer-能做什么"><a href="#Puppeteer-能做什么" class="headerlink" title="Puppeteer 能做什么"></a>Puppeteer 能做什么</h3><p>官方称：“Most things that you can do manually in the browser can be done using Puppeteer”，那么具体可以做些什么呢？</p>
<ul>
<li>  网页截图或者生成 PDF</li>
<li>  爬取 SPA 或 SSR 网站</li>
<li>  UI 自动化测试，模拟表单提交，键盘输入，点击等行为</li>
<li>  捕获网站的时间线，帮助诊断性能问题</li>
<li>  创建一个最新的自动化测试环境，使用最新的 js 和最新的 Chrome 浏览器运行测试用例</li>
<li>  测试 Chrome 扩展程序</li>
<li>  …</li>
</ul>
<h3 id="Puppeteer-API-分层结构"><a href="#Puppeteer-API-分层结构" class="headerlink" title="Puppeteer API 分层结构"></a>Puppeteer API 分层结构</h3><p>Puppeteer 中的 API 分层结构基本和浏览器保持一致，下面对常使用到的几个类介绍一下：</p>
<p><img src="/images/%E7%BB%93%E5%90%88%E9%A1%B9%E7%9B%AE%E6%9D%A5%E8%B0%88%E8%B0%88_Puppeteer/1.png"></p>
<ul>
<li>  <strong>Browser</strong>： 对应一个浏览器实例，一个 Browser 可以包含多个 BrowserContext</li>
<li>  <strong>BrowserContext</strong>： 对应浏览器一个上下文会话，就像我们打开一个普通的 Chrome 之后又打开一个隐身模式的浏览器一样，BrowserContext 具有独立的 Session(cookie 和 cache 独立不共享)，一个 BrowserContext 可以包含多个 Page</li>
<li>  <strong>Page</strong>：表示一个 Tab 页面，通过 browserContext.newPage()/browser.newPage() 创建，browser.newPage() 创建页面时会使用默认的 BrowserContext，一个 Page 可以包含多个 Frame</li>
<li>  <strong>Frame</strong>: 一个框架，每个页面有一个主框架（page.MainFrame()）,也可以多个子框架，主要由 iframe 标签创建产生的</li>
<li>  <strong>ExecutionContext</strong>： 是 javascript 的执行环境，每一个 Frame 都一个默认的 javascript 执行环境</li>
<li>  <strong>ElementHandle</strong>: 对应 DOM 的一个元素节点，通过该该实例可以实现对元素的点击，填写表单等行为，我们可以通过选择器，xPath 等来获取对应的元素</li>
<li>  <strong>JsHandle</strong>：对应 DOM 中的 javascript 对象，ElementHandle 继承于 JsHandle，由于我们无法直接操作 DOM 中对象，所以封装成 JsHandle 来实现相关功能</li>
<li>  <strong>CDPSession</strong>：可以直接与原生的 CDP 进行通信，通过 session.send 函数直接发消息，通过 session.on 接收消息，可以实现 Puppeteer API 中没有涉及的功能</li>
<li>  <strong>Coverage</strong>：获取 JavaScript 和 CSS 代码覆盖率</li>
<li>  <strong>Tracing</strong>：抓取性能数据进行分析</li>
<li>  <strong>Response</strong>： 页面收到的响应</li>
<li>  <strong>Request</strong>： 页面发出的请求</li>
</ul>
<h3 id="如何创建一个-Browser-实例"><a href="#如何创建一个-Browser-实例" class="headerlink" title="如何创建一个 Browser 实例"></a>如何创建一个 Browser 实例</h3><p>puppeteer 提供了两种方法用于创建一个 Browser 实例：</p>
<ul>
<li>  <code>puppeteer.connect</code>: 连接一个已经存在的 Chrome 实例</li>
<li>  <code>puppeteer.launch</code>: 每次都启动一个 Chrome 实例</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">&#x27;puppeteer&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> request = <span class="built_in">require</span>(<span class="string">&#x27;request-promise-native&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 puppeteer.launch 启动 Chrome</span></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.<span class="title function_">launch</span>(&#123;</span><br><span class="line">        <span class="attr">headless</span>: <span class="literal">false</span>,   <span class="comment">//有浏览器界面启动</span></span><br><span class="line">        <span class="attr">slowMo</span>: <span class="number">100</span>,       <span class="comment">//放慢浏览器执行速度，方便测试观察</span></span><br><span class="line">        <span class="attr">args</span>: [            <span class="comment">//启动 Chrome 的参数，详见上文中的介绍</span></span><br><span class="line">            <span class="string">&#x27;–no-sandbox&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;--window-size=1280,960&#x27;</span></span><br><span class="line">        ],</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> page = <span class="keyword">await</span> browser.<span class="title function_">newPage</span>();</span><br><span class="line">    <span class="keyword">await</span> page.<span class="title function_">goto</span>(<span class="string">&#x27;https://www.baidu.com&#x27;</span>);</span><br><span class="line">    <span class="keyword">await</span> page.<span class="title function_">close</span>();</span><br><span class="line">    <span class="keyword">await</span> browser.<span class="title function_">close</span>();</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 puppeteer.connect 连接一个已经存在的 Chrome 实例</span></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">//通过 9222 端口的 http 接口获取对应的 websocketUrl</span></span><br><span class="line">    <span class="keyword">let</span> version = <span class="keyword">await</span> <span class="title function_">request</span>(&#123;</span><br><span class="line">        <span class="attr">uri</span>:  <span class="string">&quot;http://127.0.0.1:9222/json/version&quot;</span>,</span><br><span class="line">        <span class="attr">json</span>: <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//直接连接已经存在的 Chrome</span></span><br><span class="line">    <span class="keyword">let</span> browser = <span class="keyword">await</span> puppeteer.<span class="title function_">connect</span>(&#123;</span><br><span class="line">        <span class="attr">browserWSEndpoint</span>: version.<span class="property">webSocketDebuggerUrl</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> page = <span class="keyword">await</span> browser.<span class="title function_">newPage</span>();</span><br><span class="line">    <span class="keyword">await</span> page.<span class="title function_">goto</span>(<span class="string">&#x27;https://www.baidu.com&#x27;</span>);</span><br><span class="line">    <span class="keyword">await</span> page.<span class="title function_">close</span>();</span><br><span class="line">    <span class="keyword">await</span> browser.<span class="title function_">disconnect</span>();</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这两种方式的对比：</p>
<ul>
<li>  <code>puppeteer.launch</code> 每次都要重新启动一个 Chrome 进程，启动平均耗时 100 到 150 ms，性能欠佳</li>
<li>  <code>puppeteer.connect</code> 可以实现对于同一个 Chrome 实例的共用，减少启动关闭浏览器的时间消耗</li>
<li>  <code>puppeteer.launch</code> 启动时参数可以动态修改</li>
<li>  通过 <code>puppeteer.connect</code> 我们可以远程连接一个 Chrome 实例，部署在不同的机器上</li>
<li>  <code>puppeteer.connect</code> 多个页面共用一个 chrome 实例，偶尔会出现 Page Crash 现象，需要进行并发控制，并定时重启 Chrome 实例</li>
</ul>
<h3 id="如何等待加载？"><a href="#如何等待加载？" class="headerlink" title="如何等待加载？"></a>如何等待加载？</h3><p>在实践中我们经常会遇到如何判断一个页面加载完成了，什么时机去截图，什么时机去点击某个按钮等问题，那我们到底如何去等待加载呢？</p>
<p>下面我们把等待加载的 API 分为三类进行介绍：</p>
<h4 id="加载导航页面"><a href="#加载导航页面" class="headerlink" title="加载导航页面"></a>加载导航页面</h4><ul>
<li>  <code>page.goto</code>：打开新页面</li>
<li>  <code>page.goBack</code>：回退到上一个页面</li>
<li>  <code>page.goForward</code>：前进到下一个页面</li>
<li>  <code>page.reload</code>：重新加载页面</li>
<li>  <code>page.waitForNavigation</code>：等待页面跳转</li>
</ul>
<p>Pupeeteer 中的基本上所有的操作都是异步的，以上几个 API 都涉及到关于打开一个页面，什么情况下才能判断这个函数执行完毕呢，这些函数都提供了两个参数 waitUtil 和 timeout，waitUtil 表示直到什么出现就算执行完毕，timeout 表示如果超过这个时间还没有结束就抛出异常。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> page.<span class="title function_">goto</span>(<span class="string">&#x27;https://www.baidu.com&#x27;</span>, &#123;</span><br><span class="line">   <span class="attr">timeout</span>: <span class="number">30</span> * <span class="number">1000</span>,</span><br><span class="line">   <span class="attr">waitUntil</span>: [</span><br><span class="line">       <span class="string">&#x27;load&#x27;</span>,              <span class="comment">//等待 “load” 事件触发</span></span><br><span class="line">       <span class="string">&#x27;domcontentloaded&#x27;</span>,  <span class="comment">//等待 “domcontentloaded” 事件触发</span></span><br><span class="line">       <span class="string">&#x27;networkidle0&#x27;</span>,      <span class="comment">//在 500ms 内没有任何网络连接</span></span><br><span class="line">       <span class="string">&#x27;networkidle2&#x27;</span>       <span class="comment">//在 500ms 内网络连接个数不超过 2 个</span></span><br><span class="line">   ]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上 waitUtil 有四个事件，业务可以根据需求来设置其中一个或者多个触发才以为结束，networkidle0 和 networkidle2 中的 500ms 对时间性能要求高的用户来说，还是有点长的</p>
<h4 id="等待元素、请求、响应"><a href="#等待元素、请求、响应" class="headerlink" title="等待元素、请求、响应"></a>等待元素、请求、响应</h4><ul>
<li>  <code>page.waitForXPath</code>：等待 xPath 对应的元素出现，返回对应的 ElementHandle 实例</li>
<li>  <code>page.waitForSelector</code>：等待选择器对应的元素出现，返回对应的 ElementHandle 实例</li>
<li>  <code>page.waitForResponse</code>：等待某个响应结束，返回 Response 实例</li>
<li>  <code>page.waitForRequest</code>：等待某个请求出现，返回 Request 实例</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> page.<span class="title function_">waitForXPath</span>(<span class="string">&#x27;//img&#x27;</span>);</span><br><span class="line"><span class="keyword">await</span> page.<span class="title function_">waitForSelector</span>(<span class="string">&#x27;#uniqueId&#x27;</span>);</span><br><span class="line"><span class="keyword">await</span> page.<span class="title function_">waitForResponse</span>(<span class="string">&#x27;https://d.youdata.netease.com/api/dash/hello&#x27;</span>);</span><br><span class="line"><span class="keyword">await</span> page.<span class="title function_">waitForRequest</span>(<span class="string">&#x27;https://d.youdata.netease.com/api/dash/hello&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="自定义等待"><a href="#自定义等待" class="headerlink" title="自定义等待"></a>自定义等待</h4><p>如果上面提供的等待方式都不能满足我们的需求，puppeteer 还提供我们提供两个函数：</p>
<ul>
<li>  <code>page.waitForFunction</code>：等待在页面中自定义函数的执行结果，返回 JsHandle 实例</li>
<li>  <code>page.waitFor</code>：设置等待时间，实在没办法的做法</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> page.<span class="title function_">goto</span>(url, &#123;</span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">120000</span>,</span><br><span class="line">    <span class="attr">waitUntil</span>: <span class="string">&#x27;networkidle2&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//我们可以在页面中定义自己认为加载完的事件，在合适的时间点我们将该事件设置为 true</span></span><br><span class="line"><span class="comment">//以下是我们项目在触发截图时的判断逻辑，如果 renderdone 出现且为 true 那么就截图，如果是 Object，说明页面加载出错了，我们可以捕获该异常进行提示</span></span><br><span class="line"><span class="keyword">let</span> renderdoneHandle = <span class="keyword">await</span> page.<span class="title function_">waitForFunction</span>(<span class="string">&#x27;window.renderdone&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">polling</span>: <span class="number">120</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> renderdone = <span class="keyword">await</span> renderdoneHandle.<span class="title function_">jsonValue</span>();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> renderdone === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`加载页面失败：报表<span class="subst">$&#123;renderdone.componentId&#125;</span>出错 -- <span class="subst">$&#123;renderdone.message&#125;</span>`</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;页面加载成功&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="两个独立的环境"><a href="#两个独立的环境" class="headerlink" title="两个独立的环境"></a>两个独立的环境</h3><p>在使用 Puppeteer 时我们几乎一定会遇到在这两个环境之间交换数据：运行 Puppeteer 的 Node.js 环境和 Puppeteer 操作的页面 Page DOM，理解这两个环境很重要</p>
<ul>
<li>  首先 Puppeteer 提供了很多有用的函数去 Page DOM Environment 中执行代码，这个后面会介绍到</li>
<li>  其次 Puppeteer 提供了 ElementHandle 和 JsHandle 将 Page DOM Environment 中元素和对象封装成对应的 Node.js 对象，这样可以直接这些对象的封装函数进行操作 Page DOM</li>
</ul>
<p><img src="/images/%E7%BB%93%E5%90%88%E9%A1%B9%E7%9B%AE%E6%9D%A5%E8%B0%88%E8%B0%88_Puppeteer/2.jpg"></p>
<h3 id="10-个用例告诉你如何使用-puppeteer"><a href="#10-个用例告诉你如何使用-puppeteer" class="headerlink" title="10 个用例告诉你如何使用 puppeteer"></a>10 个用例告诉你如何使用 puppeteer</h3><p>下面介绍 10 个关于使用 Puppeteer 的用例，并在介绍用例的时候会穿插的讲解一些 API，告诉大家如何使用 Puppeteer：</p>
<h4 id="Case1：截图"><a href="#Case1：截图" class="headerlink" title="Case1：截图"></a>Case1：截图</h4><p>我们使用 Puppeteer 既可以对某个页面进行截图，也可以对页面中的某个元素进行截图：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.<span class="title function_">launch</span>();</span><br><span class="line">    <span class="keyword">const</span> page = <span class="keyword">await</span> browser.<span class="title function_">newPage</span>();</span><br><span class="line">    <span class="comment">//设置可视区域大小</span></span><br><span class="line">    <span class="keyword">await</span> page.<span class="title function_">setViewport</span>(&#123;<span class="attr">width</span>: <span class="number">1920</span>, <span class="attr">height</span>: <span class="number">800</span>&#125;);</span><br><span class="line">    <span class="keyword">await</span> page.<span class="title function_">goto</span>(<span class="string">&#x27;https://youdata.163.com&#x27;</span>);</span><br><span class="line">    <span class="comment">//对整个页面截图</span></span><br><span class="line">    <span class="keyword">await</span> page.<span class="title function_">screenshot</span>(&#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;./files/capture.png&#x27;</span>,  <span class="comment">//图片保存路径</span></span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;png&#x27;</span>,</span><br><span class="line">        <span class="attr">fullPage</span>: <span class="literal">true</span> <span class="comment">//边滚动边截图</span></span><br><span class="line">        <span class="comment">// clip: &#123;x: 0, y: 0, width: 1920, height: 800&#125;</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//对页面某个元素截图</span></span><br><span class="line">    <span class="keyword">let</span> [element] = <span class="keyword">await</span> page.$x(<span class="string">&#x27;/html/body/section[4]/div/div[2]&#x27;</span>);</span><br><span class="line">    <span class="keyword">await</span> element.<span class="title function_">screenshot</span>(&#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;./files/element.png&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">await</span> page.<span class="title function_">close</span>();</span><br><span class="line">    <span class="keyword">await</span> browser.<span class="title function_">close</span>();</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们怎么去获取页面中的某个元素呢？</p>
<ul>
<li>  <code>page.$(&#39;#uniqueId&#39;)</code>：获取某个选择器对应的第一个元素</li>
<li>  <code>page.$$(&#39;div&#39;)</code>：获取某个选择器对应的所有元素</li>
<li>  <code>page.$x(&#39;//img&#39;)</code>：获取某个 xPath 对应的所有元素</li>
<li>  <code>page.waitForXPath(&#39;//img&#39;)</code>：等待某个 xPath 对应的元素出现</li>
<li>  <code>page.waitForSelector(&#39;#uniqueId&#39;)</code>：等待某个选择器对应的元素出现</li>
</ul>
<h4 id="case2-模拟用户登录"><a href="#case2-模拟用户登录" class="headerlink" title="case2: 模拟用户登录"></a>case2: 模拟用户登录</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.<span class="title function_">launch</span>(&#123;</span><br><span class="line">        <span class="attr">slowMo</span>: <span class="number">100</span>,    <span class="comment">//放慢速度</span></span><br><span class="line">        <span class="attr">headless</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">defaultViewport</span>: &#123;<span class="attr">width</span>: <span class="number">1440</span>, <span class="attr">height</span>: <span class="number">780</span>&#125;,</span><br><span class="line">        <span class="attr">ignoreHTTPSErrors</span>: <span class="literal">false</span>, <span class="comment">//忽略 https 报错</span></span><br><span class="line">        <span class="attr">args</span>: [<span class="string">&#x27;--start-fullscreen&#x27;</span>] <span class="comment">//全屏打开页面</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> page = <span class="keyword">await</span> browser.<span class="title function_">newPage</span>();</span><br><span class="line">    <span class="keyword">await</span> page.<span class="title function_">goto</span>(<span class="string">&#x27;https://demo.youdata.com&#x27;</span>);</span><br><span class="line">    <span class="comment">//输入账号密码</span></span><br><span class="line">    <span class="keyword">const</span> uniqueIdElement = <span class="keyword">await</span> page.$(<span class="string">&#x27;#uniqueId&#x27;</span>);</span><br><span class="line">    <span class="keyword">await</span> uniqueIdElement.<span class="title function_">type</span>(<span class="string">&#x27;admin@admin.com&#x27;</span>, &#123;<span class="attr">delay</span>: <span class="number">20</span>&#125;);</span><br><span class="line">    <span class="keyword">const</span> passwordElement = <span class="keyword">await</span> page.$(<span class="string">&#x27;#password&#x27;</span>, &#123;<span class="attr">delay</span>: <span class="number">20</span>&#125;);</span><br><span class="line">    <span class="keyword">await</span> passwordElement.<span class="title function_">type</span>(<span class="string">&#x27;123456&#x27;</span>);</span><br><span class="line">    <span class="comment">//点击确定按钮进行登录</span></span><br><span class="line">    <span class="keyword">let</span> okButtonElement = <span class="keyword">await</span> page.$(<span class="string">&#x27;#btn-ok&#x27;</span>);</span><br><span class="line">    <span class="comment">//等待页面跳转完成，一般点击某个按钮需要跳转时，都需要等待 page.waitForNavigation() 执行完毕才表示跳转成功</span></span><br><span class="line">    <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line">        okButtonElement.<span class="title function_">click</span>(),</span><br><span class="line">        page.<span class="title function_">waitForNavigation</span>()</span><br><span class="line">    ]);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;admin 登录成功&#x27;</span>);</span><br><span class="line">    <span class="keyword">await</span> page.<span class="title function_">close</span>();</span><br><span class="line">    <span class="keyword">await</span> browser.<span class="title function_">close</span>();</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么 ElementHandle 都提供了哪些操作元素的函数呢？</p>
<ul>
<li>  <code>elementHandle.click()</code>：点击某个元素</li>
<li>  <code>elementHandle.tap()</code>：模拟手指触摸点击</li>
<li>  <code>elementHandle.focus()</code>：聚焦到某个元素</li>
<li>  <code>elementHandle.hover()</code>：鼠标 hover 到某个元素上</li>
<li>  <code>elementHandle.type(&#39;hello&#39;)</code>：在输入框输入文本</li>
</ul>
<h4 id="case3：请求拦截"><a href="#case3：请求拦截" class="headerlink" title="case3：请求拦截"></a>case3：请求拦截</h4><p>请求在有些场景下很有必要，拦截一下没必要的请求提高性能，我们可以在监听 Page 的 request 事件，并进行请求拦截，前提是要开启请求拦截 page.setRequestInterception(true)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.<span class="title function_">launch</span>();</span><br><span class="line">    <span class="keyword">const</span> page = <span class="keyword">await</span> browser.<span class="title function_">newPage</span>();</span><br><span class="line">    <span class="keyword">const</span> blockTypes = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;image&#x27;</span>, <span class="string">&#x27;media&#x27;</span>, <span class="string">&#x27;font&#x27;</span>]);</span><br><span class="line">    <span class="keyword">await</span> page.<span class="title function_">setRequestInterception</span>(<span class="literal">true</span>); <span class="comment">//开启请求拦截</span></span><br><span class="line">    page.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>, <span class="function"><span class="params">request</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> type = request.<span class="title function_">resourceType</span>();</span><br><span class="line">        <span class="keyword">const</span> shouldBlock = blockTypes.<span class="title function_">has</span>(type);</span><br><span class="line">        <span class="keyword">if</span>(shouldBlock)&#123;</span><br><span class="line">            <span class="comment">//直接阻止请求</span></span><br><span class="line">            <span class="keyword">return</span> request.<span class="title function_">abort</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//对请求重写</span></span><br><span class="line">            <span class="keyword">return</span> request.<span class="title function_">continue</span>(&#123;</span><br><span class="line">                <span class="comment">//可以对 url，method，postData，headers 进行覆盖</span></span><br><span class="line">                <span class="attr">headers</span>: <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, request.<span class="title function_">headers</span>(), &#123;</span><br><span class="line">                    <span class="string">&#x27;puppeteer-test&#x27;</span>: <span class="string">&#x27;true&#x27;</span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">await</span> page.<span class="title function_">goto</span>(<span class="string">&#x27;https://demo.youdata.com&#x27;</span>);</span><br><span class="line">    <span class="keyword">await</span> page.<span class="title function_">close</span>();</span><br><span class="line">    <span class="keyword">await</span> browser.<span class="title function_">close</span>();</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那 page 页面上都提供了哪些事件呢？</p>
<ul>
<li>  <code>page.on(&#39;close&#39;)</code> 页面关闭</li>
<li>  <code>page.on(&#39;console&#39;)</code> console API 被调用</li>
<li>  <code>page.on(&#39;error&#39;)</code> 页面出错</li>
<li>  <code>page.on(&#39;load&#39;)</code> 页面加载完</li>
<li>  <code>page.on(&#39;request&#39;)</code> 收到请求</li>
<li>  <code>page.on(&#39;requestfailed&#39;)</code> 请求失败</li>
<li>  <code>page.on(&#39;requestfinished&#39;)</code> 请求成功</li>
<li>  <code>page.on(&#39;response&#39;)</code> 收到响应</li>
<li>  <code>page.on(&#39;workercreated&#39;)</code> 创建 webWorker</li>
<li>  <code>page.on(&#39;workerdestroyed&#39;)</code> 销毁 webWorker</li>
</ul>
<h4 id="case4：获取-WebSocket-响应"><a href="#case4：获取-WebSocket-响应" class="headerlink" title="case4：获取 WebSocket 响应"></a>case4：获取 WebSocket 响应</h4><p>Puppeteer 目前没有提供原生的用于处理 WebSocket 的 API 接口，但是我们可以通过更底层的 Chrome DevTool Protocol (CDP) 协议获得</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.<span class="title function_">launch</span>();</span><br><span class="line">    <span class="keyword">const</span> page = <span class="keyword">await</span> browser.<span class="title function_">newPage</span>();</span><br><span class="line">    <span class="comment">//创建 CDP 会话</span></span><br><span class="line">    <span class="keyword">let</span> cdpSession = <span class="keyword">await</span> page.<span class="title function_">target</span>().<span class="title function_">createCDPSession</span>();</span><br><span class="line">    <span class="comment">//开启网络调试,监听 Chrome DevTools Protocol 中 Network 相关事件</span></span><br><span class="line">    <span class="keyword">await</span> cdpSession.<span class="title function_">send</span>(<span class="string">&#x27;Network.enable&#x27;</span>);</span><br><span class="line">    <span class="comment">//监听 webSocketFrameReceived 事件，获取对应的数据</span></span><br><span class="line">    cdpSession.<span class="title function_">on</span>(<span class="string">&#x27;Network.webSocketFrameReceived&#x27;</span>, <span class="function"><span class="params">frame</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> payloadData = frame.<span class="property">response</span>.<span class="property">payloadData</span>;</span><br><span class="line">        <span class="keyword">if</span>(payloadData.<span class="title function_">includes</span>(<span class="string">&#x27;push:query&#x27;</span>))&#123;</span><br><span class="line">            <span class="comment">//解析payloadData，拿到服务端推送的数据</span></span><br><span class="line">            <span class="keyword">let</span> res = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(payloadData.<span class="title function_">match</span>(<span class="regexp">/\&#123;.*\&#125;/</span>)[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span>(res.<span class="property">code</span> !== <span class="number">200</span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`调用websocket接口出错:code=<span class="subst">$&#123;res.code&#125;</span>,message=<span class="subst">$&#123;res.message&#125;</span>`</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;获取到websocket接口数据：&#x27;</span>, res.<span class="property">result</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">await</span> page.<span class="title function_">goto</span>(<span class="string">&#x27;https://netease.youdata.163.com/dash/142161/reportExport?pid=700209493&#x27;</span>);</span><br><span class="line">    <span class="keyword">await</span> page.<span class="title function_">waitForFunction</span>(<span class="string">&#x27;window.renderdone&#x27;</span>, &#123;<span class="attr">polling</span>: <span class="number">20</span>&#125;);</span><br><span class="line">    <span class="keyword">await</span> page.<span class="title function_">close</span>();</span><br><span class="line">    <span class="keyword">await</span> browser.<span class="title function_">close</span>();</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="case5：植入-javascript-代码"><a href="#case5：植入-javascript-代码" class="headerlink" title="case5：植入 javascript 代码"></a>case5：植入 javascript 代码</h4><p>Puppeteer 最强大的功能是，你可以在浏览器里执行任何你想要运行的 javascript 代码，下面是我在爬 188 邮箱的收件箱用户列表时，发现每次打开收件箱再关掉都会多处一个 iframe 来，随着打开收件箱的增多，iframe 增多到浏览器卡到无法运行，所以我在爬虫代码里加了删除无用 iframe 的脚本：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.<span class="title function_">launch</span>();</span><br><span class="line">    <span class="keyword">const</span> page = <span class="keyword">await</span> browser.<span class="title function_">newPage</span>();</span><br><span class="line">    <span class="keyword">await</span> page.<span class="title function_">goto</span>(<span class="string">&#x27;https://webmail.vip.188.com&#x27;</span>);</span><br><span class="line">    <span class="comment">//注册一个 Node.js 函数，在浏览器里运行</span></span><br><span class="line">    <span class="keyword">await</span> page.<span class="title function_">exposeFunction</span>(<span class="string">&#x27;md5&#x27;</span>, <span class="function"><span class="params">text</span> =&gt;</span></span><br><span class="line">        crypto.<span class="title function_">createHash</span>(<span class="string">&#x27;md5&#x27;</span>).<span class="title function_">update</span>(text).<span class="title function_">digest</span>(<span class="string">&#x27;hex&#x27;</span>)</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//通过 page.evaluate 在浏览器里执行删除无用的 iframe 代码</span></span><br><span class="line">    <span class="keyword">await</span> page.evaluate(<span class="keyword">async</span> () =&gt;  &#123;</span><br><span class="line">        <span class="keyword">let</span> iframes = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;iframe&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">3</span>; i &lt;  iframes.<span class="property">length</span> - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">let</span> iframe = iframes[i];</span><br><span class="line">            <span class="keyword">if</span>(iframe.<span class="property">name</span>.<span class="title function_">includes</span>(<span class="string">&quot;frameBody&quot;</span>))&#123;</span><br><span class="line">                iframe.<span class="property">src</span> = <span class="string">&#x27;about:blank&#x27;</span>;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    iframe.<span class="property">contentWindow</span>.<span class="property">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">                    iframe.<span class="property">contentWindow</span>.<span class="property">document</span>.<span class="title function_">clear</span>();</span><br><span class="line">                &#125;<span class="keyword">catch</span>(e)&#123;&#125;</span><br><span class="line">                <span class="comment">//把iframe从页面移除</span></span><br><span class="line">                iframe.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(iframe);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在页面中调用 Node.js 环境中的函数</span></span><br><span class="line">        <span class="keyword">const</span> myHash = <span class="keyword">await</span> <span class="variable language_">window</span>.<span class="title function_">md5</span>(<span class="string">&#x27;PUPPETEER&#x27;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`md5 of <span class="subst">$&#123;myString&#125;</span> is <span class="subst">$&#123;myHash&#125;</span>`</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">await</span> page.<span class="title function_">close</span>();</span><br><span class="line">    <span class="keyword">await</span> browser.<span class="title function_">close</span>();</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有哪些函数可以在浏览器环境中执行代码呢？</p>
<ul>
<li>  <code>page.evaluate(pageFunction[, ...args])</code>：在浏览器环境中执行函数</li>
<li>  <code>page.evaluateHandle(pageFunction[, ...args])</code>：在浏览器环境中执行函数，返回 JsHandle 对象</li>
<li>  <code>page.$$eval(selector, pageFunction[, ...args])</code>：把 selector 对应的所有元素传入到函数并在浏览器环境执行</li>
<li>  <code>page.$eval(selector, pageFunction[, ...args])</code>：把 selector 对应的第一个元素传入到函数在浏览器环境执行</li>
<li>  <code>page.evaluateOnNewDocument(pageFunction[, ...args])</code>：创建一个新的 Document 时在浏览器环境中执行，会在页面所有脚本执行之前执行</li>
<li>  <code>page.exposeFunction(name, puppeteerFunction)</code>：在 window 对象上注册一个函数，这个函数在 Node 环境中执行，有机会在浏览器环境中调用 Node.js 相关函数库</li>
</ul>
<h4 id="case6-如何抓取-iframe-中的元素"><a href="#case6-如何抓取-iframe-中的元素" class="headerlink" title="case6: 如何抓取 iframe 中的元素"></a>case6: 如何抓取 iframe 中的元素</h4><p>一个 Frame 包含了一个执行上下文（Execution Context），我们不能跨 Frame 执行函数，一个页面中可以有多个 Frame，主要是通过 iframe 标签嵌入的生成的。其中在页面上的大部分函数其实是 <code>page.mainFrame().xx</code> 的一个简写，Frame 是树状结构，我们可以通过 <code>frame.childFrames()</code> 遍历到所有的 Frame，如果想在其它 Frame 中执行函数必须获取到对应的 Frame 才能进行相应的处理</p>
<p>以下是在登录 188 邮箱时，其登录窗口其实是嵌入的一个 iframe，以下代码时我们在获取 iframe 并进行登录</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.<span class="title function_">launch</span>(&#123;<span class="attr">headless</span>: <span class="literal">false</span>, <span class="attr">slowMo</span>: <span class="number">50</span>&#125;);</span><br><span class="line">    <span class="keyword">const</span> page = <span class="keyword">await</span> browser.<span class="title function_">newPage</span>();</span><br><span class="line">    <span class="keyword">await</span> page.<span class="title function_">goto</span>(<span class="string">&#x27;https://www.188.com&#x27;</span>);</span><br><span class="line">    <span class="comment">//点击使用密码登录</span></span><br><span class="line">    <span class="keyword">let</span> passwordLogin = <span class="keyword">await</span> page.<span class="title function_">waitForXPath</span>(<span class="string">&#x27;//*[@id=&quot;qcode&quot;]/div/div[2]/a&#x27;</span>);</span><br><span class="line">    <span class="keyword">await</span> passwordLogin.<span class="title function_">click</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> frame <span class="keyword">of</span> page.<span class="title function_">mainFrame</span>().<span class="title function_">childFrames</span>())&#123;</span><br><span class="line">        <span class="comment">//根据 url 找到登录页面对应的 iframe</span></span><br><span class="line">        <span class="keyword">if</span> (frame.<span class="title function_">url</span>().<span class="title function_">includes</span>(<span class="string">&#x27;passport.188.com&#x27;</span>))&#123;</span><br><span class="line">            <span class="keyword">await</span> frame.<span class="title function_">type</span>(<span class="string">&#x27;.dlemail&#x27;</span>, <span class="string">&#x27;admin@admin.com&#x27;</span>);</span><br><span class="line">            <span class="keyword">await</span> frame.<span class="title function_">type</span>(<span class="string">&#x27;.dlpwd&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>);</span><br><span class="line">            <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line">                frame.<span class="title function_">click</span>(<span class="string">&#x27;#dologin&#x27;</span>),</span><br><span class="line">                page.<span class="title function_">waitForNavigation</span>()</span><br><span class="line">            ]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">await</span> page.<span class="title function_">close</span>();</span><br><span class="line">    <span class="keyword">await</span> browser.<span class="title function_">close</span>();</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="case7-页面性能分析"><a href="#case7-页面性能分析" class="headerlink" title="case7: 页面性能分析"></a>case7: 页面性能分析</h4><p>Puppeteer 提供了对页面性能分析的工具，目前功能还是比较弱的，只能获取到一个页面性能执行的数据，如何分析需要我们自己根据数据进行分析，据说在 2.0 版本会做大的改版： </p>
<ul>
<li>一个浏览器同一时间只能 trace 一次 </li>
<li>在 devTools 的 Performance 可以上传对应的 json 文件并查看分析结果 </li>
<li>我们可以写脚本来解析 trace.json 中的数据做自动化分析 </li>
<li>通过 tracing 我们获取页面加载速度以及脚本的执行性能</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.<span class="title function_">launch</span>();</span><br><span class="line">    <span class="keyword">const</span> page = <span class="keyword">await</span> browser.<span class="title function_">newPage</span>();</span><br><span class="line">    <span class="keyword">await</span> page.<span class="property">tracing</span>.<span class="title function_">start</span>(&#123;<span class="attr">path</span>: <span class="string">&#x27;./files/trace.json&#x27;</span>&#125;);</span><br><span class="line">    <span class="keyword">await</span> page.<span class="title function_">goto</span>(<span class="string">&#x27;https://www.google.com&#x27;</span>);</span><br><span class="line">    <span class="keyword">await</span> page.<span class="property">tracing</span>.<span class="title function_">stop</span>();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        continue analysis from &#x27;trace.json&#x27;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    browser.<span class="title function_">close</span>();</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="case8-文件的上传和下载"><a href="#case8-文件的上传和下载" class="headerlink" title="case8: 文件的上传和下载"></a>case8: 文件的上传和下载</h4><p>在自动化测试中，经常会遇到对于文件的上传和下载的需求，那么在 Puppeteer 中如何实现呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.<span class="title function_">launch</span>();</span><br><span class="line">    <span class="keyword">const</span> page = <span class="keyword">await</span> browser.<span class="title function_">newPage</span>();</span><br><span class="line">    <span class="comment">//通过 CDP 会话设置下载路径</span></span><br><span class="line">    <span class="keyword">const</span> cdp = <span class="keyword">await</span> page.<span class="title function_">target</span>().<span class="title function_">createCDPSession</span>();</span><br><span class="line">    <span class="keyword">await</span> cdp.<span class="title function_">send</span>(<span class="string">&#x27;Page.setDownloadBehavior&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">behavior</span>: <span class="string">&#x27;allow&#x27;</span>, <span class="comment">//允许所有下载请求</span></span><br><span class="line">        <span class="attr">downloadPath</span>: <span class="string">&#x27;path/to/download&#x27;</span>  <span class="comment">//设置下载路径</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//点击按钮触发下载</span></span><br><span class="line">    <span class="keyword">await</span> (<span class="keyword">await</span> page.<span class="title function_">waitForSelector</span>(<span class="string">&#x27;#someButton&#x27;</span>)).<span class="title function_">click</span>();</span><br><span class="line">    <span class="comment">//等待文件出现，轮训判断文件是否出现</span></span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">waitForFile</span>(<span class="string">&#x27;path/to/download/filename&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上传时对应的 inputElement 必须是&lt;input&gt;元素</span></span><br><span class="line">    <span class="keyword">let</span> inputElement = <span class="keyword">await</span> page.<span class="title function_">waitForXPath</span>(<span class="string">&#x27;//input[@type=&quot;file&quot;]&#x27;</span>);</span><br><span class="line">    <span class="keyword">await</span> inputElement.<span class="title function_">uploadFile</span>(<span class="string">&#x27;/path/to/file&#x27;</span>);</span><br><span class="line">    browser.<span class="title function_">close</span>();</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="case9：跳转新-tab-页处理"><a href="#case9：跳转新-tab-页处理" class="headerlink" title="case9：跳转新 tab 页处理"></a>case9：跳转新 tab 页处理</h4><p>在点击一个按钮跳转到新的 Tab 页时会新开一个页面，这个时候我们如何获取改页面对应的 Page 实例呢？可以通过监听 Browser 上的 targetcreated 事件来实现，表示有新的页面创建：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> page = <span class="keyword">await</span> browser.<span class="title function_">newPage</span>();</span><br><span class="line"><span class="keyword">await</span> page.<span class="title function_">goto</span>(url);</span><br><span class="line"><span class="keyword">let</span> btn = <span class="keyword">await</span> page.<span class="title function_">waitForSelector</span>(<span class="string">&#x27;#btn&#x27;</span>);</span><br><span class="line"><span class="comment">//在点击按钮之前，事先定义一个 Promise，用于返回新 tab 的 Page 对象</span></span><br><span class="line"><span class="keyword">const</span> newPagePromise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">res</span> =&gt;</span></span><br><span class="line">  browser.<span class="title function_">once</span>(<span class="string">&#x27;targetcreated&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="params">target</span> =&gt;</span> <span class="title function_">res</span>(target.<span class="title function_">page</span>())</span><br><span class="line">  )</span><br><span class="line">);</span><br><span class="line"><span class="keyword">await</span> btn.<span class="title function_">click</span>();</span><br><span class="line"><span class="comment">//点击按钮后，等待新tab对象</span></span><br><span class="line"><span class="keyword">let</span> newPage = <span class="keyword">await</span> newPagePromise;</span><br></pre></td></tr></table></figure>

<h4 id="case10-模拟不同的设备"><a href="#case10-模拟不同的设备" class="headerlink" title="case10: 模拟不同的设备"></a>case10: 模拟不同的设备</h4><p>Puppeteer 提供了模拟不同设备的功能，其中 puppeteer.devices 对象上定义很多设备的配置信息，这些配置信息主要包含 viewport 和 userAgent，然后通过函数 page.emulate 实现不同设备的模拟</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">&#x27;puppeteer&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> iPhone = puppeteer.<span class="property">devices</span>[<span class="string">&#x27;iPhone 6&#x27;</span>];</span><br><span class="line">puppeteer.<span class="title function_">launch</span>().<span class="title function_">then</span>(<span class="keyword">async</span> browser =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.<span class="title function_">newPage</span>();</span><br><span class="line">  <span class="keyword">await</span> page.<span class="title function_">emulate</span>(iPhone);</span><br><span class="line">  <span class="keyword">await</span> page.<span class="title function_">goto</span>(<span class="string">&#x27;https://www.google.com&#x27;</span>);</span><br><span class="line">  <span class="keyword">await</span> browser.<span class="title function_">close</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Puppeteer-vs-Phantomjs"><a href="#Puppeteer-vs-Phantomjs" class="headerlink" title="Puppeteer vs Phantomjs"></a>Puppeteer vs Phantomjs</h3><ul>
<li>  完全真实的浏览器操作，支持所有 Chrome 特性</li>
<li>  可以提供不同版本的 Chrome 浏览器环境</li>
<li>  Chrome 团队维护，拥有更好的兼容性和前景</li>
<li>  headless 参数动态配置，调试更为方便，通过 –remote-debugging-port=9222，可以进入调试界面调试</li>
<li>  支持最新的 JS 语法，比如 async/await 等</li>
<li>  完备的事件驱动机制，不需要太多的 sleep</li>
<li>  Phantomjs 环境安装复杂，API 调用不友好</li>
<li>  两者的主要不同在于 Phantomjs 使用了一个较老版本的 WebKit 作为它的渲染引擎</li>
<li>  比 Phantomjs 有更快更好的性能，以下是其他人对于 Puppeteer 和 Phantomjs 性能对比结果：</li>
</ul>
<p><a href="https://link.zhihu.com/?target=https://hackernoon.com/benchmark-headless-chrome-vs-phantomjs-e7f44c6956c">Headless Chrome vs PhantomJS Benchmark</a></p>
<p><img src="/images/%E7%BB%93%E5%90%88%E9%A1%B9%E7%9B%AE%E6%9D%A5%E8%B0%88%E8%B0%88_Puppeteer/3.jpg"></p>
<h3 id="Puppeteer-在我们团队的应用场景"><a href="#Puppeteer-在我们团队的应用场景" class="headerlink" title="Puppeteer 在我们团队的应用场景"></a>Puppeteer 在我们团队的应用场景</h3><p><img src="/images/%E7%BB%93%E5%90%88%E9%A1%B9%E7%9B%AE%E6%9D%A5%E8%B0%88%E8%B0%88_Puppeteer/4.jpg"></p>
<h3 id="性能和优化"><a href="#性能和优化" class="headerlink" title="性能和优化"></a>性能和优化</h3><ul>
<li>  关于共享内存：</li>
</ul>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Chrome 默认使用 <span class="regexp">/dev/</span>shm 共享内存，但是 docker 默认<span class="regexp">/dev/</span>shm 只有<span class="number">64</span>MB，显然是不够使用的，提供两种方式来解决：</span><br><span class="line">- 启动 docker 时添加参数 --shm-<span class="keyword">size</span>=<span class="number">1</span>gb 来增大 <span class="regexp">/dev/</span>shm 共享内存，但是 swarm 目前不支持 shm-<span class="keyword">size</span> 参数</span><br><span class="line">- 启动 Chrome 添加参数 - disable-dev-shm-usage，禁止使用 <span class="regexp">/dev/</span>shm 共享内存</span><br></pre></td></tr></table></figure>

<ul>
<li>  尽量使用同一个浏览器实例，这样可以实现缓存共用</li>
<li>  通过请求拦截没必要加载的资源</li>
<li>  像我们自己打开 Chrome 一样，tab 页多必然会卡，所以必须有效控制 tab 页个数</li>
<li>  一个 Chrome 实例启动时间长了难免会出现内存泄漏，页面奔溃等现象，所以定时重启 Chrome 实例是有必要的</li>
<li>  为了加快性能，关闭没必要的配置，比如：-no-sandbox（沙箱功能），--disable-extensions（扩展程序）等</li>
<li>  尽量避免使用 page.waifFor(1000)，让程序自己决定效果会更好</li>
<li>  因为和 Chrome 实例连接时使用的 Websocket，会存在 Websocket sticky session 问题，这个需要特别注意</li>
</ul>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li>  <a href="https://link.zhihu.com/?target=http://blog.xcatliu.com/2018/09/18/puppeteer_tutorial/">Puppeteer 指南</a></li>
<li>  <a href="https://link.zhihu.com/?target=https://blog.it2048.cn/article-puppeteer-speed-up/">Puppeteer 性能优化与执行速度提升</a></li>
<li>  <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/33015883">phantomJs之殇，chrome-headless之生</a></li>
<li>  <a href="https://link.zhihu.com/?target=https://hackernoon.com/benchmark-headless-chrome-vs-phantomjs-e7f44c6956c">Headless Chrome vs PhantomJS Benchmark</a></li>
<li>  <a href="https://link.zhihu.com/?target=https://kb.apify.com/en/articles/2116540-scraping-iframes-with-puppeteer">Scraping iframes with Puppeteer</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://moqiang02.github.io/2020/07/02/%E7%BB%93%E5%90%88%E9%A1%B9%E7%9B%AE%E6%9D%A5%E8%B0%88%E8%B0%88Puppeteer/" data-id="cla0v66gt024hg0v14au8fvyj" data-title="结合项目来谈谈 Puppeteer" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%88%AC%E8%99%AB/" rel="tag">爬虫</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/07/02/%E5%88%A9%E7%94%A8puppeteer%E7%A0%B4%E8%A7%A3%E6%9E%81%E9%AA%8C%E7%9A%84%E6%BB%91%E5%8A%A8%E9%AA%8C%E8%AF%81/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          利用puppeteer破解极验的滑动验证
        
      </div>
    </a>
  
  
    <a href="/2020/07/01/%E4%BD%BF%E7%94%A8Puppeteer%E4%BB%8E%E4%B8%80%E7%BB%84DOM%E8%8A%82%E7%82%B9%E4%B8%AD%E8%8E%B7%E5%8F%96%E6%9F%90%E4%B8%80%E5%B1%9E%E6%80%A7%E5%80%BC/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">使用Puppeteer从一组DOM节点中获取某一属性值</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/android/">android</a><span class="category-list-count">255</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/apache/">apache</a><span class="category-list-count">27</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/flutter/">flutter</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/github%E5%8D%9A%E5%AE%A2/">github博客</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/go/">go</a><span class="category-list-count">26</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/html-css/">html+css</a><span class="category-list-count">24</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iis/">iis</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">55</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/">javascript</a><span class="category-list-count">114</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/kotlin/">kotlin</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">68</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mac/">mac</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/memcached/">memcached</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mongodb/">mongodb</a><span class="category-list-count">19</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a><span class="category-list-count">72</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/">nginx</a><span class="category-list-count">41</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/nodejs/">nodejs</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/php/">php</a><span class="category-list-count">185</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a><span class="category-list-count">44</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%B6%E5%AE%83/">其它</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a><span class="category-list-count">50</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/">开源项目</a><span class="category-list-count">73</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/">生活随笔</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93/">量化交易</a><span class="category-list-count">3</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/AndroidStudio/" style="font-size: 13.75px;">AndroidStudio</a> <a href="/tags/AndroidUI/" style="font-size: 20px;">AndroidUI</a> <a href="/tags/Android%E4%BA%8B%E4%BB%B6%E6%8B%A6%E6%88%AA/" style="font-size: 11.25px;">Android事件拦截</a> <a href="/tags/Android%E5%BC%80%E6%BA%90/" style="font-size: 18.13px;">Android开源</a> <a href="/tags/CI/" style="font-size: 15.63px;">CI</a> <a href="/tags/CURL/" style="font-size: 13.13px;">CURL</a> <a href="/tags/DEDE/" style="font-size: 19.38px;">DEDE</a> <a href="/tags/Docker/" style="font-size: 14.38px;">Docker</a> <a href="/tags/Flask/" style="font-size: 10.63px;">Flask</a> <a href="/tags/JavaSE/" style="font-size: 17.5px;">JavaSE</a> <a href="/tags/Laravel/" style="font-size: 18.13px;">Laravel</a> <a href="/tags/Maven/" style="font-size: 10.63px;">Maven</a> <a href="/tags/SVN/" style="font-size: 10px;">SVN</a> <a href="/tags/SpringBoot/" style="font-size: 18.75px;">SpringBoot</a> <a href="/tags/Thinkphp/" style="font-size: 10px;">Thinkphp</a> <a href="/tags/UEditor/" style="font-size: 11.88px;">UEditor</a> <a href="/tags/VMware/" style="font-size: 12.5px;">VMware</a> <a href="/tags/Vue/" style="font-size: 18.13px;">Vue</a> <a href="/tags/WebSocket/" style="font-size: 13.13px;">WebSocket</a> <a href="/tags/ecshop/" style="font-size: 15px;">ecshop</a> <a href="/tags/scrapy/" style="font-size: 14.38px;">scrapy</a> <a href="/tags/smarty/" style="font-size: 12.5px;">smarty</a> <a href="/tags/socket/" style="font-size: 15px;">socket</a> <a href="/tags/sphinx/" style="font-size: 11.88px;">sphinx</a> <a href="/tags/vagrant/" style="font-size: 12.5px;">vagrant</a> <a href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" style="font-size: 11.25px;">微服务</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/" style="font-size: 15.63px;">数据传输</a> <a href="/tags/%E6%AD%A3%E5%88%99/" style="font-size: 11.88px;">正则</a> <a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size: 16.25px;">消息队列</a> <a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size: 16.88px;">爬虫</a> <a href="/tags/%E9%9B%86%E7%BE%A4/" style="font-size: 17.5px;">集群</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/11/27/Java%E6%95%99%E7%A8%8B%E7%B4%A2%E5%BC%95/">Java教程索引</a>
          </li>
        
          <li>
            <a href="/2022/11/03/Ubuntu%E5%AE%89%E8%A3%85Docker/">Ubuntu安装Docker</a>
          </li>
        
          <li>
            <a href="/2022/11/02/Dockerfile-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/">Dockerfile 最佳实践</a>
          </li>
        
          <li>
            <a href="/2022/11/02/Docker-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/">Docker 快速入门</a>
          </li>
        
          <li>
            <a href="/2022/11/02/SpringBoot-%E5%AE%9E%E7%8E%B0-Websocket-%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/">SpringBoot 实现 Websocket 通信详解(小豆丁技术栈)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 moqiang<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>

<!-- rex -->

<script src="/js/toc.js"></script>


  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>