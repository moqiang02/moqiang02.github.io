<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>asyncio异步IO--协程（Coroutine）与任务(Task)详解 | 自强不息</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="摘要：本文翻译自Coroutines and Tasks，主要介绍asyncio中用于处理协程和任务的方法和接口。在翻译过程中，译者在官方文档的基础上增加了部分样例代码和示意图表，以帮助读者对文档的理解。本文内容主要针对python3.7，在低版本的python中可能不适用，敬请留意。">
<meta property="og:type" content="article">
<meta property="og:title" content="asyncio异步IO--协程（Coroutine）与任务(Task)详解">
<meta property="og:url" content="http://moqiang02.github.io/2019/04/21/asyncio%E5%BC%82%E6%AD%A5IO-%E5%8D%8F%E7%A8%8B%EF%BC%88Coroutine%EF%BC%89%E4%B8%8E%E4%BB%BB%E5%8A%A1-Task-%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="自强不息">
<meta property="og:description" content="摘要：本文翻译自Coroutines and Tasks，主要介绍asyncio中用于处理协程和任务的方法和接口。在翻译过程中，译者在官方文档的基础上增加了部分样例代码和示意图表，以帮助读者对文档的理解。本文内容主要针对python3.7，在低版本的python中可能不适用，敬请留意。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://moqiang02.github.io/images/asyncio%E5%BC%82%E6%AD%A5IO/1.png">
<meta property="article:published_time" content="2019-04-21T03:23:39.000Z">
<meta property="article:modified_time" content="2022-10-26T09:28:53.940Z">
<meta property="article:author" content="moqiang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://moqiang02.github.io/images/asyncio%E5%BC%82%E6%AD%A5IO/1.png">
  
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">自强不息</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://moqiang02.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-asyncio异步IO-协程（Coroutine）与任务-Task-详解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/04/21/asyncio%E5%BC%82%E6%AD%A5IO-%E5%8D%8F%E7%A8%8B%EF%BC%88Coroutine%EF%BC%89%E4%B8%8E%E4%BB%BB%E5%8A%A1-Task-%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2019-04-21T03:23:39.000Z" itemprop="datePublished">2019-04-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      asyncio异步IO--协程（Coroutine）与任务(Task)详解
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      

          <!-- rex -->
          
            <!-- 文章目录开始 -->
            
              <div id="toc" class="toc-article">
              <strong class="toc-title" style="cursor:pointer">目录</strong>
              <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">协程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%9C%E5%8F%AF%E7%AD%89%E5%BE%85%E2%80%9D%E5%AF%B9%E8%B1%A1%EF%BC%88Awaitables%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">“可等待”对象（Awaitables）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Coroutine%EF%BC%88%E5%8D%8F%E7%A8%8B%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">Coroutine（协程）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Task%EF%BC%88%E4%BB%BB%E5%8A%A1%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">Task（任务）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Future%EF%BC%88%E6%9C%AA%E6%9D%A5%E5%AF%B9%E8%B1%A1%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">Future（未来对象）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8Casyncio%E7%A8%8B%E5%BA%8F"><span class="toc-number">3.</span> <span class="toc-text">执行asyncio程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BATask"><span class="toc-number">4.</span> <span class="toc-text">创建Task</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sleeping"><span class="toc-number">5.</span> <span class="toc-text">Sleeping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8CTasks"><span class="toc-number">6.</span> <span class="toc-text">并发执行Tasks</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E5%8F%96%E6%B6%88"><span class="toc-number">6.1.</span> <span class="toc-text">避免取消</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%EF%BC%88Timeouts%EF%BC%89"><span class="toc-number">7.</span> <span class="toc-text">超时（Timeouts）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E5%8E%9F%E8%AF%AD%EF%BC%88Waiting-Primitives%EF%BC%89"><span class="toc-number">8.</span> <span class="toc-text">等待原语（Waiting Primitives）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%85%B6%E4%BB%96%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%89%A7%E8%A1%8C%EF%BC%88Scheduling-From-Other-Threads%EF%BC%89"><span class="toc-number">9.</span> <span class="toc-text">从其他线程调度执行（Scheduling From Other Threads）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E6%9F%A5%EF%BC%88Introspection%EF%BC%89"><span class="toc-number">10.</span> <span class="toc-text">自查（Introspection）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Task%E5%AF%B9%E8%B1%A1"><span class="toc-number">11.</span> <span class="toc-text">Task对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E5%8D%8F%E7%A8%8B%EF%BC%88Generator-based-Coroutines%EF%BC%89"><span class="toc-number">12.</span> <span class="toc-text">基于生成器的协程（Generator-based Coroutines）</span></a></li></ol>
              </div>
            
            <!-- 文章目录结束 -->	  
          

        <p>摘要：本文翻译自Coroutines and Tasks，主要介绍asyncio中用于处理协程和任务的方法和接口。在翻译过程中，译者在官方文档的基础上增加了部分样例代码和示意图表，以帮助读者对文档的理解。本文内容主要针对python3.7，在低版本的python中可能不适用，敬请留意。</p>
<span id="more"></span>
<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>协程（coroutines）是通过async/await定义函数或方法，是使用asyncio进行异步编程的首选途径。如下，是一个协程的例子：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">  <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;world&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>上例中的 main 方法就是我们定义的协程 。代码的功能很简单：<br><img src="/images/asyncio%E5%BC%82%E6%AD%A5IO/1.png"></p>
<p>我们在交互环境(Python3.7)下执行以上代码，看看效果：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&quot;world&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>asyncio.run(main())</span><br><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure>
<p>需要注意的是：如果像执行普通代码一样直接调用main()，只会返回一个coroutine对象，main()方法内的代码不会执行：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>main() <span class="comment">#直接执行main()返回的是一个coroutine对象。</span></span><br><span class="line">&lt;coroutine <span class="built_in">object</span> main at <span class="number">0x0000000002C97848</span>&gt;</span><br></pre></td></tr></table></figure>
<p>实际上，asyncio提供了三种执行协程的机制：</p>
<ul>
<li><strong>使用asyncio.run()执行协程。一般用于执行最顶层的入口函数，如main()。</strong></li>
<li><strong>await一个协程。一般用于在一个协程中调用另一协程。</strong> 如下是一个示例：</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> time</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">say_after</span>(<span class="params">delay,what</span>):</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">        <span class="built_in">print</span>(what)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;started at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">await</span> say_after(<span class="number">1</span>,<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">        <span class="keyword">await</span> say_after(<span class="number">2</span>,<span class="string">&quot;world&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;finished at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>asyncio.run(main())</span><br><span class="line">started at <span class="number">16</span>:<span class="number">47</span>:<span class="number">10</span></span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">finished at <span class="number">16</span>:<span class="number">47</span>:<span class="number">13</span></span><br></pre></td></tr></table></figure>
<p>执行耗时 <strong>3秒</strong></p>
<ul>
<li><strong>用<code>asyncio.create_task()</code>方法将Coroutine（协程）封装为Task（任务）。一般用于实现异步并发操作。</strong> 需要注意的是，只有在当前线程存在事件循环的时候才能创建任务（Task）。</li>
</ul>
<p>我们修改以上的例程，<strong>并发执行</strong>两个say_after协程。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    task1 = asyncio.create_task(say_after(<span class="number">1</span>,<span class="string">&quot;hello&quot;</span>))</span><br><span class="line">    task2 = asyncio.create_task(say_after(<span class="number">2</span>,<span class="string">&quot;world&quot;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;started at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> task1</span><br><span class="line">    <span class="keyword">await</span> task2</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;finished at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>执行<code>asyncio.run(main())</code>,结果如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">started at <span class="number">17</span>:01:<span class="number">34</span></span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">finished at <span class="number">17</span>:01:<span class="number">36</span></span><br></pre></td></tr></table></figure>
<p><strong>耗时2秒</strong></p>
<h3 id="“可等待”对象（Awaitables）"><a href="#“可等待”对象（Awaitables）" class="headerlink" title="“可等待”对象（Awaitables）"></a>“可等待”对象（Awaitables）</h3><p>如果一个对象能够被用在await表达式中，那么我们称这个对象是可等待对象（awaitable object）。很多asyncio API都被设计成了可等待的。<br>主要有三类可等待对象：</p>
<ul>
<li>协程coroutine</li>
<li>任务Task</li>
<li>未来对象Future。</li>
</ul>
<h4 id="Coroutine（协程）"><a href="#Coroutine（协程）" class="headerlink" title="Coroutine（协程）"></a>Coroutine（协程）</h4><p>Python的协程是可等待的（awaitable），因此能够被其他协程用在await表达式中。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">nested</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;something&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 如果直接调用 &quot;nested()&quot;，什么都不会发生.</span></span><br><span class="line">    <span class="comment"># 直接调用的时候只是创建了一个 协程对象 ，但这个对象没有被 await,</span></span><br><span class="line">    <span class="comment"># 所以它并不会执行.</span></span><br><span class="line">    nested()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 那么我们 await 这个协程，看看会是什么结果:</span></span><br><span class="line">    <span class="keyword">await</span> nested()  <span class="comment"># 将会打印 &quot;something&quot;.</span></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>重要：</strong>在这篇文章中，术语coroutine或协程指代两个关系紧密的概念：</p>
<ul>
<li>协程函数（coroutine function）:由async def定义的函数；</li>
<li>协程对象（coroutine object）：调用 协程函数返回的对象。</li>
</ul>
<p>asyncio也支持传统的基于生成器的协程。</p>
<h4 id="Task（任务）"><a href="#Task（任务）" class="headerlink" title="Task（任务）"></a>Task（任务）</h4><p>Task用来 并发的 调度协程。<br>当一个协程通过类似<code> asyncio.create_task()</code> 的函数被封装进一个 Task时，这个协程 会很快被自动调度执行：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">nested</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># Schedule nested() to run soon concurrently</span></span><br><span class="line">    <span class="comment"># with &quot;main()&quot;.</span></span><br><span class="line">    task = asyncio.create_task(nested())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># &quot;task&quot; can now be used to cancel &quot;nested()&quot;, or</span></span><br><span class="line">    <span class="comment"># can simply be awaited to wait until it is complete:</span></span><br><span class="line">    <span class="keyword">await</span> task</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>

<h4 id="Future（未来对象）"><a href="#Future（未来对象）" class="headerlink" title="Future（未来对象）"></a>Future（未来对象）</h4><p>Future 是一种特殊的<strong>底层</strong>可等待对象，代表一个异步操作的最终结果。<br>当一个Future对象被await的时候，表示当前的协程会持续等待，直到 Future对象所指向的异步操作执行完毕。<br>在asyncio中，Future对象能使<strong>基于回调</strong>的代码被用于<code>asyn/await</code>表达式中。<br>一般情况下，在应用层编程中，<strong>没有必要</strong>创建Future对象。<br>有时候，有些Future对象会被一些库和asyncio API暴露出来，我们可以await它们：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">await</span> function_that_returns_a_future_object()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># this is also valid:</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(</span><br><span class="line">        function_that_returns_a_future_object(),</span><br><span class="line">        some_python_coroutine()</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<p>底层函数返回Future对象的一个例子是：<a target="_blank" rel="noopener" href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.run_in_executor">loop.run_in_executor</a></p>
<h3 id="执行asyncio程序"><a href="#执行asyncio程序" class="headerlink" title="执行asyncio程序"></a>执行asyncio程序</h3><p><code>asyncio.run(coro, * , debug=False)</code><br>这个函数运行coro参数指定的<code>协程</code>，负责<strong>管理asyncio事件循环 ， 终止异步生成器</strong>。<br>在同一个线程中，当已经有asyncio事件循环在执行时，不能调用此函数。<br>如果<code>debug=True</code>，事件循环将运行在<strong>调试模式</strong>。<br>此函数总是创建一个新的事件循环，并在最后关闭它。建议将它用作asyncio程序的主入口，并且只调用一次。<br>Python3.7新增<br>重要：这个函数是在Python3.7被临时添加到asyncio中的。</p>
<h3 id="创建Task"><a href="#创建Task" class="headerlink" title="创建Task"></a>创建Task</h3><p><code>asyncio.create_task(coro)</code><br>将coro参数指定的协程（coroutine）封装到一个Task中，并调度执行。返回值是一个Task对象。<br>任务在由<code>get_running_loop()</code>返回的事件循环（loop）中执行。如果当前线程中没有正在运行的事件循环，将会引发RuntimeError异常:</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">coro_1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;do somthing&quot;</span>)</span><br><span class="line"></span><br><span class="line">task = asyncio.create_task(coro_1())</span><br></pre></td></tr></table></figure>
<p>因为当前线程中没有正运行的事件循环，所以引发异常：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;C:\Program Files\Python37\lib\site-packages\IPython\core\interactiveshell.py&quot;</span>, line <span class="number">3265</span>, <span class="keyword">in</span> run_code</span><br><span class="line">    <span class="built_in">exec</span>(code_obj, self.user_global_ns, self.user_ns)</span><br><span class="line">  File <span class="string">&quot;&lt;ipython-input-4-456c15a4ed16&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    task = asyncio.create_task(coro_1())</span><br><span class="line">  File <span class="string">&quot;C:\Program Files\Python37\lib\asyncio\tasks.py&quot;</span>, line <span class="number">324</span>, <span class="keyword">in</span> create_task</span><br><span class="line">    loop = events.get_running_loop()</span><br><span class="line">RuntimeError: no running event loop</span><br></pre></td></tr></table></figure>
<p>对以上代码稍作修改，创建main()方法，在其中创建Task对象，然后在主程序中利用<code>asyncio.run()</code>创建事件循环：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">coro</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;something is running&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    task = asyncio.create_task(coro())</span><br><span class="line">    <span class="built_in">print</span>(asyncio.get_running_loop())   </span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;_WindowsSelectorEventLoop <span class="attribute">running</span>=<span class="literal">True</span> <span class="attribute">closed</span>=<span class="literal">False</span> <span class="attribute">debug</span>=<span class="literal">False</span>&gt;</span><br><span class="line">something is running</span><br></pre></td></tr></table></figure>
<p>此函数已经被引入到Python3.7。在Python早期版本中，可以使用底层函数<code>asyncio.ensure_future()</code>代替。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">coro</span>():</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># In Python 3.7+</span></span><br><span class="line">task = asyncio.create_task(coro())</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># This works in all Python versions but is less readable</span></span><br><span class="line">task = asyncio.ensure_future(coro())</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>Python3.7新增</p>
<h3 id="Sleeping"><a href="#Sleeping" class="headerlink" title="Sleeping"></a>Sleeping</h3><p><code>coroutine asyncio.sleep(delay,result=None,* ,loop=None)</code><br>阻塞delay秒，例如delay=3，则阻塞3秒。<br>如果指定了result参数的值，则在协程结束时，将该值返回给调用者。<br>sleep()通常只暂停当前task，并不影响其他task的执行。<br>不建议使用loop参数，因为Python计划在3.10版本中移除它。<br>以下是一个协程的例子，功能是在5秒钟内，每秒显示一次当前的日期：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">display_date</span>():</span><br><span class="line">    loop = asyncio.get_running_loop()</span><br><span class="line">    end_time = loop.time() + <span class="number">5.0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(datetime.datetime.now())</span><br><span class="line">        <span class="keyword">if</span> (loop.time() + <span class="number">1.0</span>) &gt;= end_time:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">asyncio.run(display_date())</span><br></pre></td></tr></table></figure>
<p>执行结果大致如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">20</span> <span class="number">11</span>:<span class="number">27</span>:<span class="number">15.961830</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">20</span> <span class="number">11</span>:<span class="number">27</span>:<span class="number">16.961887</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">20</span> <span class="number">11</span>:<span class="number">27</span>:<span class="number">17.961944</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">20</span> <span class="number">11</span>:<span class="number">27</span>:<span class="number">18.962001</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">20</span> <span class="number">11</span>:<span class="number">27</span>:<span class="number">19.962059</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">20</span> <span class="number">11</span>:<span class="number">27</span>:<span class="number">20.962116</span></span><br></pre></td></tr></table></figure>

<h3 id="并发执行Tasks"><a href="#并发执行Tasks" class="headerlink" title="并发执行Tasks"></a>并发执行Tasks</h3><p><code>awaitable asyncio.gather(* aws, loop=None, return_exceptions=False)</code><br>并发执行aws参数指定的 可等待（awaitable）对象序列。<br>如果aws序列中的某个awaitable对象是一个协程,则自动将这个协程封装为Task对象进行处理。例如：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">factorial</span>(<span class="params">name, number</span>):</span><br><span class="line">    f = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, number + <span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Task <span class="subst">&#123;name&#125;</span>: Compute factorial(<span class="subst">&#123;i&#125;</span>)...&quot;</span>)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">        f *= i</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Task <span class="subst">&#123;name&#125;</span>: factorial(<span class="subst">&#123;number&#125;</span>) = <span class="subst">&#123;f&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># Schedule three calls *concurrently*:</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(</span><br><span class="line">        factorial(<span class="string">&quot;A&quot;</span>, <span class="number">2</span>),</span><br><span class="line">        factorial(<span class="string">&quot;B&quot;</span>, <span class="number">3</span>),</span><br><span class="line">        factorial(<span class="string">&quot;C&quot;</span>, <span class="number">4</span>),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Expected output:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     Task A: Compute factorial(2)...</span></span><br><span class="line"><span class="comment">#     Task B: Compute factorial(2)...</span></span><br><span class="line"><span class="comment">#     Task C: Compute factorial(2)...</span></span><br><span class="line"><span class="comment">#     Task A: factorial(2) = 2</span></span><br><span class="line"><span class="comment">#     Task B: Compute factorial(3)...</span></span><br><span class="line"><span class="comment">#     Task C: Compute factorial(3)...</span></span><br><span class="line"><span class="comment">#     Task B: factorial(3) = 6</span></span><br><span class="line"><span class="comment">#     Task C: Compute factorial(4)...</span></span><br><span class="line"><span class="comment">#     Task C: factorial(4) = 24</span></span><br></pre></td></tr></table></figure>
<p>如果所有的awaitable对象都执行完毕，则返回<strong>awaitable对象执行结果的聚合列表</strong>。返回值的顺序于aws参数的顺序一致。<br>简单修改以上代码：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">factorial</span>(<span class="params">name, number</span>):</span><br><span class="line">    f = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, number + <span class="number">1</span>):</span><br><span class="line">        <span class="comment">#print(f&quot;Task &#123;name&#125;: Compute factorial(&#123;i&#125;)...&quot;)</span></span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">        f *= i</span><br><span class="line"></span><br><span class="line">    <span class="comment">#print(f&quot;Task &#123;name&#125;: factorial(&#123;number&#125;) = &#123;f&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">return</span> number</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># Schedule three calls *concurrently*:</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="keyword">await</span> asyncio.gather(</span><br><span class="line">        factorial(<span class="string">&quot;A&quot;</span>, <span class="number">2</span>),</span><br><span class="line">        factorial(<span class="string">&quot;B&quot;</span>, <span class="number">3</span>),</span><br><span class="line">        factorial(<span class="string">&quot;C&quot;</span>, <span class="number">4</span>),</span><br><span class="line">    ))</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Expected output:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#[2, 3, 4]#await asyncio.gather()的返回值是一个列表，</span></span><br><span class="line"><span class="comment">#分别对应factorial(&quot;A&quot;, 2),factorial(&quot;B&quot;, 3),factorial(&quot;C&quot;, 4)的执行结果。</span></span><br></pre></td></tr></table></figure>
<p>如果return_execptions参数为False（默认值即为False），引发的第一个异常会立即传播给等待gather()的任务，即调用<code>await asyncio.gather()</code>对象。序列中其他awaitable对象的执行不会受影响。例如：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">division</span>(<span class="params">divisor, dividend</span>):</span><br><span class="line">    <span class="keyword">if</span> divisor == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ZeroDivisionError</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;dividend&#125;</span>/<span class="subst">&#123;divisor&#125;</span>=<span class="subst">&#123;dividend/divisor&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> dividend/divisor</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># Schedule three calls *concurrently*:</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="keyword">await</span> asyncio.gather(</span><br><span class="line">        division(<span class="number">0</span>, <span class="number">2</span>),</span><br><span class="line">        division(<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">        division(<span class="number">2</span>, <span class="number">2</span>),</span><br><span class="line">    ))</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>/<span class="number">1</span>=<span class="number">2.0</span></span><br><span class="line"><span class="number">2</span>/<span class="number">2</span>=<span class="number">1.0</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;test.py&quot;</span>, line <span class="number">19</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    asyncio.run(main())</span><br><span class="line">  File <span class="string">&quot;c:\Program Files\Python37\lib\asyncio\runners.py&quot;</span>, line <span class="number">43</span>, <span class="keyword">in</span> run</span><br><span class="line">    <span class="keyword">return</span> loop.run_until_complete(main)</span><br><span class="line">  File <span class="string">&quot;c:\Program Files\Python37\lib\asyncio\base_events.py&quot;</span>, line <span class="number">573</span>, <span class="keyword">in</span> run_until_complete</span><br><span class="line">    <span class="keyword">return</span> future.result()</span><br><span class="line">  File <span class="string">&quot;test.py&quot;</span>, line <span class="number">16</span>, <span class="keyword">in</span> main</span><br><span class="line">    division(<span class="number">2</span>, <span class="number">2</span>),</span><br><span class="line">  File <span class="string">&quot;test.py&quot;</span>, line <span class="number">6</span>, <span class="keyword">in</span> division</span><br><span class="line">    <span class="keyword">raise</span> ZeroDivisionError</span><br><span class="line">ZeroDivisionError</span><br></pre></td></tr></table></figure>
<p>如果return_exceptions参数为True，异常会和正常结果一样，被聚合到结果列表中返回。<br>对以上代码稍作修改，将return_exceptions设为True：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">division</span>(<span class="params">divisor, dividend</span>):</span><br><span class="line">    <span class="keyword">if</span> divisor == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ZeroDivisionError</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;dividend&#125;</span>/<span class="subst">&#123;divisor&#125;</span>=<span class="subst">&#123;dividend/divisor&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> dividend/divisor</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># Schedule three calls *concurrently*:</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="keyword">await</span> asyncio.gather(</span><br><span class="line">        division(<span class="number">0</span>, <span class="number">2</span>),</span><br><span class="line">        division(<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">        division(<span class="number">2</span>, <span class="number">2</span>),</span><br><span class="line">        return_exceptions=<span class="literal">True</span></span><br><span class="line">    ))</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>/<span class="number">1</span>=<span class="number">2.0</span></span><br><span class="line"><span class="number">2</span>/<span class="number">2</span>=<span class="number">1.0</span></span><br><span class="line">[ZeroDivisionError(), <span class="number">2.0</span>, <span class="number">1.0</span>]<span class="comment">#错误不会向上传播，而是作为结果返回</span></span><br></pre></td></tr></table></figure>
<p>如果gather()被取消，则提交的所有awaitable对象（尚未执行完成的）都会被取消。例如：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">division</span>(<span class="params">divisor, dividend</span>):</span><br><span class="line">    <span class="keyword">if</span> divisor == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ZeroDivisionError</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(divisor)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;dividend&#125;</span>/<span class="subst">&#123;divisor&#125;</span>=<span class="subst">&#123;dividend/divisor&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> dividend/divisor</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># Schedule three calls *concurrently*:</span></span><br><span class="line">    t = asyncio.gather(</span><br><span class="line">        division(<span class="number">0</span>, <span class="number">2</span>),</span><br><span class="line">        division(<span class="number">1</span>, <span class="number">5</span>),</span><br><span class="line">        division(<span class="number">3</span>, <span class="number">6</span>),</span><br><span class="line">        return_exceptions=<span class="literal">True</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    t.cancel()</span><br><span class="line">    <span class="keyword">await</span> t</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>/<span class="number">1</span>=<span class="number">5.0</span> <span class="comment">#除已执行的之外，其他的任务全部被取消</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;test.py&quot;</span>, line <span class="number">23</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    asyncio.run(main())</span><br><span class="line">  File <span class="string">&quot;c:\Program Files\Python37\lib\asyncio\runners.py&quot;</span>, line <span class="number">43</span>, <span class="keyword">in</span> run</span><br><span class="line">    <span class="keyword">return</span> loop.run_until_complete(main)</span><br><span class="line">  File <span class="string">&quot;c:\Program Files\Python37\lib\asyncio\base_events.py&quot;</span>, line <span class="number">573</span>, <span class="keyword">in</span> run_until_complete</span><br><span class="line">    <span class="keyword">return</span> future.result()</span><br><span class="line">concurrent.futures._base.CancelledError</span><br><span class="line"><span class="comment">#在return_exceptions=True的情况下，异常依然向上传播。</span></span><br></pre></td></tr></table></figure>
<p>如果aws中某些Task或Future被取消，gather()调用不会被取消，被取消的Task或Future会以引发CancelledError的方式被处理。这样可以避免个别awaitable对象的取消操作影响其他awaitable对象的执行。<br>例如：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">division</span>(<span class="params">divisor, dividend</span>):</span><br><span class="line">    <span class="keyword">if</span> divisor == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ZeroDivisionError</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(divisor)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;dividend&#125;</span>/<span class="subst">&#123;divisor&#125;</span>=<span class="subst">&#123;dividend/divisor&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> dividend/divisor</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># Schedule three calls *concurrently*:</span></span><br><span class="line">    task1 = asyncio.create_task(division(<span class="number">0</span>, <span class="number">2</span>))</span><br><span class="line">    task2 = asyncio.create_task(division(<span class="number">1</span>, <span class="number">5</span>))</span><br><span class="line">    task3 = asyncio.create_task(division(<span class="number">3</span>, <span class="number">6</span>))</span><br><span class="line">    t = asyncio.gather(</span><br><span class="line">        task1,</span><br><span class="line">        task2,</span><br><span class="line">        task3,</span><br><span class="line">        return_exceptions=<span class="literal">True</span></span><br><span class="line">    )</span><br><span class="line">    task1.cancel()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="keyword">await</span> t)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p>预期执行结果如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>/<span class="number">1</span>=<span class="number">5.0</span></span><br><span class="line"><span class="number">6</span>/<span class="number">3</span>=<span class="number">2.0</span></span><br><span class="line">[CancelledError(), <span class="number">5.0</span>, <span class="number">2.0</span>] <span class="comment"># 仅task1被取消，其他任务不受影响。</span></span><br></pre></td></tr></table></figure>
<h4 id="避免取消"><a href="#避免取消" class="headerlink" title="避免取消"></a>避免取消</h4><p><code>awaitable asyncio.shield(aw, * , loop=None)</code><br>防止awaitable对象被<a target="_blank" rel="noopener" href="https://docs.python.org/3/library/asyncio-task.html#asyncio.Task.cancel">取消(cancelled)</a>执行。<br>如果aw参数是一个协程(coroutines),该对象会被自动封装为Task对象进行处理。<br>通常，代码：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#code 1</span></span><br><span class="line">res = <span class="keyword">await</span> shield(something())</span><br></pre></td></tr></table></figure>
<p>同代码：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#code 2</span></span><br><span class="line">res = <span class="keyword">await</span> something()</span><br></pre></td></tr></table></figure>
<p>是等价的。<br>特殊情况是，如果包含以上代码的协程被 取消，code 1与code 2的执行效果就完全不同了：</p>
<ul>
<li>code 1中，运行于something()中的任务<strong>不会被取消</strong>。</li>
<li>code 2中，运行于something()中的任务<strong>会被取消</strong>。</li>
</ul>
<p>在code 1中，从something()的视角看，取消操作并没有发生。然而，事实上它的调用者确实被取消了，所以<code>await shield(something())</code>仍然会引发一个CancelledError异常。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">division</span>(<span class="params">divisor, dividend</span>):</span><br><span class="line">    <span class="keyword">if</span> divisor == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ZeroDivisionError</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(divisor)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;time.strftime(<span class="string">&#x27;%X&#x27;</span>)&#125;</span>:<span class="subst">&#123;dividend&#125;</span>/<span class="subst">&#123;divisor&#125;</span>=<span class="subst">&#123;dividend/divisor&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> dividend/divisor</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># Schedule three calls *concurrently*:</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Start time:<span class="subst">&#123;time.strftime(<span class="string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    task1 = asyncio.shield(division(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">    task2 = asyncio.create_task(division(<span class="number">1</span>, <span class="number">5</span>))</span><br><span class="line">    task3 = asyncio.create_task(division(<span class="number">3</span>, <span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">    res = asyncio.gather(task1, task2, task3, return_exceptions=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    task1.cancel()</span><br><span class="line">    task2.cancel()</span><br><span class="line">    <span class="built_in">print</span>(<span class="keyword">await</span> res)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Start time:<span class="number">10</span>:<span class="number">38</span>:<span class="number">48</span></span><br><span class="line"><span class="number">10</span>:<span class="number">38</span>:<span class="number">49</span>:<span class="number">2</span>/<span class="number">1</span>=<span class="number">2.0</span></span><br><span class="line"><span class="number">10</span>:<span class="number">38</span>:<span class="number">51</span>:<span class="number">6</span>/<span class="number">3</span>=<span class="number">2.0</span></span><br><span class="line">[CancelledError(), CancelledError(), <span class="number">2.0</span>]</span><br><span class="line"><span class="comment">#task1虽然被取消，但是division(1,2)依然正常执行了。</span></span><br><span class="line"><span class="comment">#task2被取消后，division(1,5)没有执行</span></span><br><span class="line"><span class="comment">#虽然task1内的协程被执行，但返回值依然为CancelledError</span></span><br></pre></td></tr></table></figure>
<p>如果something()以其他的方式被取消，比如从自身内部取消，那么shield()也会被取消。<br>如果希望完全忽略取消操作（不推荐这么做），则可以将shield()与try/except结合起来使用：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    res = <span class="keyword">await</span> shield(something())</span><br><span class="line"><span class="keyword">except</span> CancelledError:</span><br><span class="line">    res = <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<h3 id="超时（Timeouts）"><a href="#超时（Timeouts）" class="headerlink" title="超时（Timeouts）"></a>超时（Timeouts）</h3><p><code>coroutine asyncio.wait_for(aw,timeout,*,loop=None)</code><br>在timeout时间之内，等待aw参数指定的awaitable对象执行完毕。<br>如果aw是一个协程，则会被自动作为Task处理。<br>timeout可以是None也可以是一个float或int类型的数字，表示需要等待的秒数。如果timeout是None，则永不超时，一直阻塞到aw执行完毕。<br>如果达到timeout时间，将会取消待执行的任务，引发<code>asyncio.TimeoutError.</code><br>如果想避免任务被取消，可以将其封装在shield()中。<br>程序会等待到任务确实被取消掉，所以等待的总时间会比timeout略大。<br>如果await_for()被取消，aw也会被取消。<br>loop参数将在Python3.10中删除，所以不推荐使用。<br>示例：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">eternity</span>():</span><br><span class="line">    <span class="comment"># Sleep for one hour</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">3600</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;yay!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># Wait for at most 1 second</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">await</span> asyncio.wait_for(eternity(), timeout=<span class="number">1.0</span>)</span><br><span class="line">    <span class="keyword">except</span> asyncio.TimeoutError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;timeout!&#x27;</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Expected output:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     timeout!</span></span><br></pre></td></tr></table></figure>
<p>Python3.7新特性：当aw因为超时被取消，wait_for()等到aw确实被取消之后返回异常。在以前的版本中，wait_for会立即返回异常。</p>
<h3 id="等待原语（Waiting-Primitives）"><a href="#等待原语（Waiting-Primitives）" class="headerlink" title="等待原语（Waiting Primitives）"></a>等待原语（Waiting Primitives）</h3><p><strong>wait()</strong><br><code>coroutine asyncio.wait(aws,*,loop=None,timeout=None,return_when=ALL_COMPLETED)</code><br>并发执行aws中的awaitable对象，一直阻塞到return_when指定的情况出现。<br>如果aws中的某些对象是协程（coroutine），则自动转换为Task对象进行处理。直接将coroutine对象传递给wait()会导致令人迷惑的执行结果，所以不建议这么做。<br>返回值是两个Task/Future集合:(done,pending)。<br>用法示例：<br><code>done,pending = await asyncio.wait(aws)</code><br>loop参数将在Python3.10中删除，所以不建议使用。<br>timeout参数可以是一个int或float类型的值，可以控制最大等待时间。<br>需要注意的是，wait()不会引发asyncio.TimeoutError错误。返回前没有被执行的Future和Task会被简单的放入pending集合。<br>return_when决定函数返回的时机。它只能被设置为以下常量：</p>
<table>
<thead>
<tr>
<th>Constant</th>
<th align="right">Description</th>
</tr>
</thead>
<tbody><tr>
<td>FIRST_COMPLETED</td>
<td align="right">The function will return when any future finishes or is cancelled.</td>
</tr>
<tr>
<td>FIRST_EXCEPTION</td>
<td align="right">The function will return when any future finishes by raising an exception. If no future raises an exception then it is equivalent to ALL_COMPLETED.</td>
</tr>
<tr>
<td>ALL_COMPLETED</td>
<td align="right">The function will return when all futures finish or are cancelled.</td>
</tr>
</tbody></table>
<p>与wait_for()不同，wait()不会再超时的时候取消任务。<br>注意：<br>因为wait()会自动将协程转换为Task对象进行处理，然后返回这些隐式创建的Task到（done,pending）集合，所以以下代码不会如预期的那样执行。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line">coro = foo()</span><br><span class="line">done, pending = <span class="keyword">await</span> asyncio.wait(&#123;coro&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> coro <span class="keyword">in</span> done:</span><br><span class="line">    <span class="comment"># 因为wait()会自动将协程转换为Task对象进行处理，然后返回这些隐式创建的Task到（done,pending）集合，所以这个条件分支永远不会被执行。</span></span><br></pre></td></tr></table></figure>
<p>上面的代码可以做如下修正：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line">task = asyncio.create_task(foo())</span><br><span class="line">done, pending = <span class="keyword">await</span> asyncio.wait(&#123;task&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> task <span class="keyword">in</span> done:</span><br><span class="line">    <span class="comment"># 这回可以正常执行了.</span></span><br></pre></td></tr></table></figure>
<p>所以，正如上文所讲，不建议将coroutine对象直接传递给wait()。</p>
<p><strong>as_completed()</strong><br><code>asyncio.as_completed(aws,*,loop=None,timeout=None)</code><br>并发执行aws中的awaitable对象。返回一个Future对象迭代器。每次迭代时返回的Future对象代表待执行的awaitable对象集合里最早出现的结果。<strong>注意：</strong>迭代器返回的顺序与aws列表的顺序无关，只与结果出现的早晚有关。<br>如果超时之前还有Future对象未完成，则引发<code>asyncio.TimeoutError</code>异常。<br>用法示例：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> as_completed(aws):</span><br><span class="line">    earliest_result = <span class="keyword">await</span> f</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
<p>以下为一个完整的例子：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">eternity</span>(<span class="params">delay</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;delay for <span class="subst">&#123;delay&#125;</span> seconds.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> delay</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Start at: <span class="subst">&#123;time.strftime(<span class="string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    tasks = [eternity(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> asyncio.as_completed(tasks):</span><br><span class="line">        res = <span class="keyword">await</span> f</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;End at: <span class="subst">&#123;time.strftime(<span class="string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Start at: <span class="number">17</span>:<span class="number">19</span>:<span class="number">11</span></span><br><span class="line">delay <span class="keyword">for</span> <span class="number">0</span> seconds.</span><br><span class="line">delay <span class="keyword">for</span> <span class="number">1</span> seconds.</span><br><span class="line">delay <span class="keyword">for</span> <span class="number">2</span> seconds.</span><br><span class="line">delay <span class="keyword">for</span> <span class="number">3</span> seconds.</span><br><span class="line">delay <span class="keyword">for</span> <span class="number">4</span> seconds.</span><br><span class="line">delay <span class="keyword">for</span> <span class="number">5</span> seconds.</span><br><span class="line">delay <span class="keyword">for</span> <span class="number">6</span> seconds.</span><br><span class="line">delay <span class="keyword">for</span> <span class="number">7</span> seconds.</span><br><span class="line">delay <span class="keyword">for</span> <span class="number">8</span> seconds.</span><br><span class="line">delay <span class="keyword">for</span> <span class="number">9</span> seconds.</span><br><span class="line">End at: <span class="number">17</span>:<span class="number">19</span>:<span class="number">20</span></span><br></pre></td></tr></table></figure>

<h3 id="从其他线程调度执行（Scheduling-From-Other-Threads）"><a href="#从其他线程调度执行（Scheduling-From-Other-Threads）" class="headerlink" title="从其他线程调度执行（Scheduling From Other Threads）"></a>从其他线程调度执行（Scheduling From Other Threads）</h3><p><code>asyncio.run_coroutine_threadsafe(coro,loop)</code><br>向loop指定的事件循环提交一个由coro指定协程。线程安全。<br>返回一个concurrent.futures.Future对象，等待另一个线程返回结果。<br>这个函数用于从当前线程向运行事件循环的线程提交协程(coroutine)。<br>例如：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create a coroutine</span></span><br><span class="line">coro = asyncio.sleep(<span class="number">1</span>, result=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Submit the coroutine to a given loop</span></span><br><span class="line">future = asyncio.run_coroutine_threadsafe(coro, loop)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Wait for the result with an optional timeout argument</span></span><br><span class="line"><span class="keyword">assert</span> future.result(timeout) == <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>如果协程出现异常，返回的Future会收到通知。返回的Future也可以被用作取消事件循环中的任务：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    result = future.result(timeout)</span><br><span class="line"><span class="keyword">except</span> asyncio.TimeoutError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;The coroutine took too long, cancelling the task...&#x27;</span>)</span><br><span class="line">    future.cancel()</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> exc:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;The coroutine raised an exception: <span class="subst">&#123;exc!r&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;The coroutine returned: <span class="subst">&#123;result!r&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>可以参考<a target="_blank" rel="noopener" href="https://docs.python.org/3/library/asyncio-dev.html#asyncio-multithreading">并发与多线程</a>章节。<br>与其他asyncio函数不同，该函数需要 显式 传递loop参数。<br>新增于Python 3.5.1</p>
<h3 id="自查（Introspection）"><a href="#自查（Introspection）" class="headerlink" title="自查（Introspection）"></a>自查（Introspection）</h3><p><strong>current_task()</strong><br><code>asyncio.current_task(loop=None)</code><br>返回事件循环中正在运行的Task实例，如果没有Task在执行，则返回None。<br>如果loop为None,则使用get_running_loop()获取当前事件循环。<br>新增于Python3.7</p>
<p><strong>all_tasks()</strong><br><code>asyncio.all_tasks(loop=None)</code><br>返回事件循环中尚未运行结束的Task对象集合。<br>如果loop为None，则，使用get_running_loop()获取当前事件循环。<br>新增于Python3.7</p>
<h3 id="Task对象"><a href="#Task对象" class="headerlink" title="Task对象"></a>Task对象</h3><p><code>class asyncio.Task(coro,*,loop=None)</code><br>类似与Future对象，用于执行Python协程。非线程安全。<br>Tasks用于在事件循环中执行协程。如果协程等待一个Future，那么Task会暂停协程的执行，直到Future执行完成。当Future完成时，协程的执行会恢复。<br>事件循环的 协作调度 模式：一个事件循环同一时间只执行一个Task。当这个Task等待某个Future返回时，事件循环执行其他的Task、回调或IO操作。</p>
<p>可以通过高层函数asyncio.create_task()创建Task，或者通过底层函数loop.create_task()和ensure_future()创建Task。但是不建议直接实例化Task对象。</p>
<p>如果想要取消一个Task的执行，可以使用cancel()方法。调用cancel()会引起Task对象向被封装的协程抛出CancelledError异常。当取消行为发生时，如果协程正在等待某个Future对象执行，该Future对象将被取消。</p>
<p>cancelled()方法用于检查某个Task是否已被取消。如果Task封装的协程没有阻止CancelledError异常，且Task确实被取消了，则该方法返回True。</p>
<p>asyncio.Task继承了Future类中除Future.set_result()和Future.set_exception()以外的所有方法。</p>
<p>Task对象支持contextvars模块：当一个Task被创建的时候，它会复制当前的上下文，然后在复制的上下文副本中执行协程。</p>
<p>Python3.7中的变更：添加了对contextvars模块的支持。</p>
<p><strong>cancel()</strong><br>申请取消任务。<br>将在下一个事件循环周期中将CancelledError异常抛给封装在Task中的协程。<br>收到CancelledError异常后，协程有机会处理异常，甚至以<code>try ...except CancelledError ...finally</code>来拒绝请求。因此，与Future.cancel()不同，Task.cancel()不能保证Task一定被取消掉。当然，拒绝取消请求这种操作并不常见，而且很不提倡。</p>
<p>以下例子可以说明协程如何拦截取消请求：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">cancel_me</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;cancel_me(): before sleep&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># Wait for 1 hour</span></span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">3600</span>)</span><br><span class="line">    <span class="keyword">except</span> asyncio.CancelledError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;cancel_me(): cancel sleep&#x27;</span>)</span><br><span class="line">        <span class="keyword">raise</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;cancel_me(): after sleep&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># Create a &quot;cancel_me&quot; Task</span></span><br><span class="line">    task = asyncio.create_task(cancel_me())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Wait for 1 second</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    task.cancel()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">await</span> task</span><br><span class="line">    <span class="keyword">except</span> asyncio.CancelledError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;main(): cancel_me is cancelled now&quot;</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Expected output:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     cancel_me(): before sleep</span></span><br><span class="line"><span class="comment">#     cancel_me(): cancel sleep</span></span><br><span class="line"><span class="comment">#     cancel_me(): after sleep</span></span><br><span class="line"><span class="comment">#     main(): cancel_me is cancelled now</span></span><br></pre></td></tr></table></figure>

<p><strong>cancelled()</strong><br>如果Task已经被取消，则返回True。<br>当取消请求通过cancel()被提交，且Task封装的协程传播了抛给它的CancelledError异常，则此Task被取消。</p>
<p><strong>done()</strong><br>如果Task已完成，则返回True。<br>Task完成有三种情况：</p>
<ul>
<li>封装的协程已返回</li>
<li>封装的协程已抛出异常</li>
<li>Task被取消</li>
</ul>
<p><strong>result()</strong><br>返回Task的执行结果。<br>如果Task已经完成，则返回Task封装的协程的执行结果（如果Task封装的协程引发异常，则重新引发该异常）。<br>如果Task已经取消，则该方法引发CancelledError异常。<br>如果Task的结果还不可用，该方法引发InvalidStateError异常。</p>
<p><strong>exception()</strong><br>返回Task的异常。<br>如果封装的协程引发了异常，则返回此异常。如果封装的协程执行正常，则返回None。<br>如果Task已被取消，则引发CancelledError异常。<br>如果Task尚未完成，则引发InvalidStateError异常。</p>
<p><strong>add_done_callback()</strong><br>添加一个回调函数，在Task完成后执行。<br>这个方法只应用在基于回调的底层编程中。<br>具体细节可以参考<code>Future.remove_done_callback()</code></p>
<p><em><em>get_stack(</em> ,limit=None)</em>*<br>返回此Task的堆栈帧列表。</p>
<ul>
<li>如果封装的协程未完成，此方法返回它暂停位置的堆栈。</li>
<li>如果封装的协程已经完成或已被取消，此方法返回一个空的列表。</li>
<li>如果封装的协程因异常而结束，此方法返回异常回溯列表。</li>
</ul>
<p>帧的顺序总是<strong>由旧到新</strong>。<br>暂停中的协程只返回一个堆栈帧。<br>可选参数limit用于限定返回帧的最大数目。默认情况下，所有有效的帧都会返回。<br>在返回堆栈和返回异常回溯时，列表的顺序会有所不同：</p>
<ul>
<li>最新的堆栈帧会被返回</li>
<li>最老的回溯帧会被返回（这和异常回溯模块的机制有关）</li>
</ul>
<p><em><em>print_stack(</em> ,limit=None,file=None)</em>*<br>打印Task的栈帧或异常回溯。<br>此方法用于输出由get_stack()取回的帧列表，输出形式类似于回溯(traceback)模块<br>limit参数会直接传递给get_stack()。<br>file参数指定输出的I/O流，默认为sys.stderr。</p>
<p><strong>classmethod all_tasks(loop=None)</strong><br>返回一个事件循环上所有任务的集合。<br>默认情况下，当前事件循环上所有的任务都会被返回。如果loop参数为’None’，则通过get_event_loop()方法获取当前事件循环。</p>
<p>此方法将在Python3.9中被移除，所以不建议使用。可以使用asyncio.all_tasks()代替。</p>
<p><strong>calssmethod current_task(loop=None)</strong><br>返回当前正在运行的Task或None。<br>如果loop参数为<code>None</code>，则通过get_event_loop()方法获取当前事件循环。<br>此方法将在Python3.9中被移除，所以不建议使用。可以使用asyncio.current_task()代替。</p>
<h3 id="基于生成器的协程（Generator-based-Coroutines）"><a href="#基于生成器的协程（Generator-based-Coroutines）" class="headerlink" title="基于生成器的协程（Generator-based Coroutines）"></a>基于生成器的协程（Generator-based Coroutines）</h3><p>提示：对基于生成器的协程的支持将在Python3.10中移除，不建议使用。<br>基于生成器的协程是早期的异步实现方式，出现在<code>async/await</code>语法之前，使用<code>yield from</code>表达式等待Future或其他协程。<br>基于生成器的协程应该用<code> @asyncio.coroutine</code>来修饰，尽管这不是强制的。</p>
<p>** @asyncio.coroutine**<br>基于生成器的协程的修饰器。<br>这个修饰器能使传统的<code>基于生成器的协程</code>与<code>async/await</code>语法兼容：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">old_style_coroutine</span>():</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">await</span> old_style_coroutine()</span><br></pre></td></tr></table></figure>
<p>此修饰器将在Python3.10中被移除，所以不建议再使用。<br>此修饰器不能用于<code>async def</code>的协程中。</p>
<p><strong>asyncio.iscoroutine(obj)</strong><br>如果obj对象是一个coroutine对象，则返回True。<br>此方法与inspect.iscoroutine()不同，因为它对基于生成器的协程也返回True。</p>
<p><strong>asyncio.iscoroutinefunction(func)</strong><br>如果func是一个coroutine方法，则返回True。<br>此方法inspect.iscoroutinefunction()不同，因为它对用@coroutine修饰的基于生成器的协程也返回True。</p>
<blockquote>
<p>转自：<a target="_blank" rel="noopener" href="https://ashooter.github.io/2018-11-19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Python%E7%9A%84asyncio%E5%8D%8F%E7%A8%8B/">asyncio异步IO–协程（Coroutine）与任务(Task)详解</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://moqiang02.github.io/2019/04/21/asyncio%E5%BC%82%E6%AD%A5IO-%E5%8D%8F%E7%A8%8B%EF%BC%88Coroutine%EF%BC%89%E4%B8%8E%E4%BB%BB%E5%8A%A1-Task-%E8%AF%A6%E8%A7%A3/" data-id="cla0v662y0188g0v1cd9ubvff" data-title="asyncio异步IO--协程（Coroutine）与任务(Task)详解" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/04/21/%E4%BD%BF%E7%94%A8asyncio%E5%A4%84%E7%90%86%E5%B9%B6%E5%8F%91/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          使用asyncio处理并发
        
      </div>
    </a>
  
  
    <a href="/2019/04/20/Scrapy%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B9%8BDownloader-Middleware%E7%9A%84%E7%94%A8%E6%B3%95/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">Scrapy框架的使用之Downloader Middleware的用法</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/android/">android</a><span class="category-list-count">255</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/apache/">apache</a><span class="category-list-count">27</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/flutter/">flutter</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/github%E5%8D%9A%E5%AE%A2/">github博客</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/go/">go</a><span class="category-list-count">26</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/html-css/">html+css</a><span class="category-list-count">24</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iis/">iis</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">62</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/">javascript</a><span class="category-list-count">114</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/kotlin/">kotlin</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">68</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mac/">mac</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/memcached/">memcached</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mongodb/">mongodb</a><span class="category-list-count">19</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a><span class="category-list-count">72</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/">nginx</a><span class="category-list-count">41</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/nodejs/">nodejs</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/php/">php</a><span class="category-list-count">185</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a><span class="category-list-count">44</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%B6%E5%AE%83/">其它</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a><span class="category-list-count">51</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/">开源项目</a><span class="category-list-count">73</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/">生活随笔</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93/">量化交易</a><span class="category-list-count">3</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/AndroidStudio/" style="font-size: 13.75px;">AndroidStudio</a> <a href="/tags/AndroidUI/" style="font-size: 20px;">AndroidUI</a> <a href="/tags/Android%E4%BA%8B%E4%BB%B6%E6%8B%A6%E6%88%AA/" style="font-size: 11.25px;">Android事件拦截</a> <a href="/tags/Android%E5%BC%80%E6%BA%90/" style="font-size: 18.13px;">Android开源</a> <a href="/tags/CI/" style="font-size: 15.63px;">CI</a> <a href="/tags/CURL/" style="font-size: 13.13px;">CURL</a> <a href="/tags/DEDE/" style="font-size: 18.75px;">DEDE</a> <a href="/tags/Docker/" style="font-size: 15px;">Docker</a> <a href="/tags/Flask/" style="font-size: 10.63px;">Flask</a> <a href="/tags/JavaSE/" style="font-size: 18.13px;">JavaSE</a> <a href="/tags/Laravel/" style="font-size: 18.13px;">Laravel</a> <a href="/tags/Maven/" style="font-size: 10.63px;">Maven</a> <a href="/tags/SVN/" style="font-size: 10px;">SVN</a> <a href="/tags/SpringBoot/" style="font-size: 19.38px;">SpringBoot</a> <a href="/tags/Thinkphp/" style="font-size: 10px;">Thinkphp</a> <a href="/tags/UEditor/" style="font-size: 11.88px;">UEditor</a> <a href="/tags/VMware/" style="font-size: 12.5px;">VMware</a> <a href="/tags/Vue/" style="font-size: 18.13px;">Vue</a> <a href="/tags/WebSocket/" style="font-size: 13.13px;">WebSocket</a> <a href="/tags/ecshop/" style="font-size: 15px;">ecshop</a> <a href="/tags/scrapy/" style="font-size: 14.38px;">scrapy</a> <a href="/tags/smarty/" style="font-size: 12.5px;">smarty</a> <a href="/tags/socket/" style="font-size: 15px;">socket</a> <a href="/tags/sphinx/" style="font-size: 11.88px;">sphinx</a> <a href="/tags/vagrant/" style="font-size: 12.5px;">vagrant</a> <a href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" style="font-size: 11.25px;">微服务</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/" style="font-size: 15.63px;">数据传输</a> <a href="/tags/%E6%AD%A3%E5%88%99/" style="font-size: 11.88px;">正则</a> <a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size: 16.25px;">消息队列</a> <a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size: 16.88px;">爬虫</a> <a href="/tags/%E9%9B%86%E7%BE%A4/" style="font-size: 17.5px;">集群</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/11/27/Java%E6%95%99%E7%A8%8B%E7%B4%A2%E5%BC%95/">Java教程索引</a>
          </li>
        
          <li>
            <a href="/2022/11/20/SpringBoot%E6%B3%A8%E8%A7%A3%E4%B9%8B-Configuration%E3%80%81-Bean%E3%80%81-Component/">SpringBoot注解之@Configuration、@Bean、@Component</a>
          </li>
        
          <li>
            <a href="/2022/11/15/SpringBoot%E6%8E%A5%E6%94%B6%E8%AF%B7%E6%B1%82%E7%9A%84N%E7%A7%8D%E5%A7%BF%E5%8A%BF/">SpringBoot接收请求的N种姿势</a>
          </li>
        
          <li>
            <a href="/2022/11/15/%E4%BD%BF%E7%94%A8Springboot%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E6%8D%A2%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%8F%82%E6%95%B0%E5%8E%BB%E7%A9%BA%E6%A0%BC%E5%8A%9F%E8%83%BD/">使用Springboot自定义转换器实现参数去空格功能</a>
          </li>
        
          <li>
            <a href="/2022/11/15/RESTful%E5%BC%80%E5%8F%91%E6%97%A5%E6%9C%9F%E7%B1%BB%E5%9E%8B%E5%AD%97%E6%AE%B5%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E4%BC%A0%E9%80%92/">RESTful开发日期类型字段如何正确传递</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 moqiang<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>

<!-- rex -->

<script src="/js/toc.js"></script>


  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>