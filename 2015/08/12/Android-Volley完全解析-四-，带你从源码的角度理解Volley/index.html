<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Android Volley完全解析(四)，带你从源码的角度理解Volley | 自强不息</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="经过前三篇文章的学习，Volley的用法我们已经掌握的差不多了，但是对于Volley的工作原理，恐怕有很多朋友还不是很清楚。因此，本篇文章中我们就来一起阅读一下Volley的源码，将它的工作流程整体地梳理一遍。同时，这也是Volley系列的最后一篇文章了。 其实，Volley的官方文档中本身就附有了一张Volley的工作流程图，如下图所示。">
<meta property="og:type" content="article">
<meta property="og:title" content="Android Volley完全解析(四)，带你从源码的角度理解Volley">
<meta property="og:url" content="http://moqiang02.github.io/2015/08/12/Android-Volley%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90-%E5%9B%9B-%EF%BC%8C%E5%B8%A6%E4%BD%A0%E4%BB%8E%E6%BA%90%E7%A0%81%E7%9A%84%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3Volley/index.html">
<meta property="og:site_name" content="自强不息">
<meta property="og:description" content="经过前三篇文章的学习，Volley的用法我们已经掌握的差不多了，但是对于Volley的工作原理，恐怕有很多朋友还不是很清楚。因此，本篇文章中我们就来一起阅读一下Volley的源码，将它的工作流程整体地梳理一遍。同时，这也是Volley系列的最后一篇文章了。 其实，Volley的官方文档中本身就附有了一张Volley的工作流程图，如下图所示。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://moqiang02.github.io/images/Volley%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90%E5%9B%9B%E5%B8%A6%E4%BD%A0%E4%BB%8E%E6%BA%90%E7%A0%81%E7%9A%84%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3Volley/1.jpg">
<meta property="og:image" content="http://moqiang02.github.io/images/Volley%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90%E5%9B%9B%E5%B8%A6%E4%BD%A0%E4%BB%8E%E6%BA%90%E7%A0%81%E7%9A%84%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3Volley/1.jpg">
<meta property="article:published_time" content="2015-08-12T15:04:10.000Z">
<meta property="article:modified_time" content="2022-10-26T09:28:53.667Z">
<meta property="article:author" content="moqiang">
<meta property="article:tag" content="Android开源">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://moqiang02.github.io/images/Volley%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90%E5%9B%9B%E5%B8%A6%E4%BD%A0%E4%BB%8E%E6%BA%90%E7%A0%81%E7%9A%84%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3Volley/1.jpg">
  
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">自强不息</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://moqiang02.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Android-Volley完全解析-四-，带你从源码的角度理解Volley" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2015/08/12/Android-Volley%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90-%E5%9B%9B-%EF%BC%8C%E5%B8%A6%E4%BD%A0%E4%BB%8E%E6%BA%90%E7%A0%81%E7%9A%84%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3Volley/" class="article-date">
  <time class="dt-published" datetime="2015-08-12T15:04:10.000Z" itemprop="datePublished">2015-08-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/android/">android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Android Volley完全解析(四)，带你从源码的角度理解Volley
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      

          <!-- rex -->
          

        <p>经过前三篇文章的学习，Volley的用法我们已经掌握的差不多了，但是对于Volley的工作原理，恐怕有很多朋友还不是很清楚。因此，本篇文章中我们就来一起阅读一下Volley的源码，将它的工作流程整体地梳理一遍。同时，这也是Volley系列的最后一篇文章了。</p>
<p>其实，Volley的官方文档中本身就附有了一张Volley的工作流程图，如下图所示。<span id="more"></span><br><img src="/images/Volley%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90%E5%9B%9B%E5%B8%A6%E4%BD%A0%E4%BB%8E%E6%BA%90%E7%A0%81%E7%9A%84%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3Volley/1.jpg"></p>
<p>多数朋友突然看到一张这样的图，应该会和我一样，感觉一头雾水吧？没错，目前我们对Volley背后的工作原理还没有一个概念性的理解，直接就来看这张图自然会有些吃力。不过没关系，下面我们就去分析一下Volley的源码，之后再重新来看这张图就会好理解多了。</p>
<p>说起分析源码，那么应该从哪儿开始看起呢？这就要回顾一下Volley的用法了，还记得吗，使用Volley的第一步，首先要调用Volley.newRequestQueue(context)方法来获取一个RequestQueue对象，那么我们自然要从这个方法开始看起了，代码如下所示：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="keyword">new</span><span class="type">RequestQueue</span>(Context context) &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span><span class="type">RequestQueue</span>(context, <span class="literal">null</span>);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>这个方法仅仅只有一行代码，只是调用了newRequestQueue()的方法重载，并给第二个参数传入null。那我们看下带有两个参数的newRequestQueue()方法中的代码，如下所示：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static RequestQueue <span class="keyword">new</span><span class="constructor">RequestQueue(Context <span class="params">context</span>, HttpStack <span class="params">stack</span>)</span> &#123;  </span><br><span class="line">    File cacheDir = <span class="keyword">new</span> <span class="constructor">File(<span class="params">context</span>.<span class="params">getCacheDir</span>()</span>, DEFAULT_CACHE_DIR);  </span><br><span class="line">    String userAgent = <span class="string">&quot;volley/0&quot;</span>;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        String packageName = context.get<span class="constructor">PackageName()</span>;  </span><br><span class="line">        PackageInfo info = context.get<span class="constructor">PackageManager()</span>.get<span class="constructor">PackageInfo(<span class="params">packageName</span>, 0)</span>;  </span><br><span class="line">        userAgent = packageName + <span class="string">&quot;/&quot;</span> + info.versionCode;  </span><br><span class="line">    &#125; catch (NameNotFoundException e) &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (stack<span class="operator"> == </span>null) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">9</span>) &#123;  </span><br><span class="line">            stack = <span class="keyword">new</span> <span class="constructor">HurlStack()</span>;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            stack = <span class="keyword">new</span> <span class="constructor">HttpClientStack(AndroidHttpClient.<span class="params">newInstance</span>(<span class="params">userAgent</span>)</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    Network network = <span class="keyword">new</span> <span class="constructor">BasicNetwork(<span class="params">stack</span>)</span>;  </span><br><span class="line">    RequestQueue queue = <span class="keyword">new</span> <span class="constructor">RequestQueue(<span class="params">new</span> DiskBasedCache(<span class="params">cacheDir</span>)</span>, network);  </span><br><span class="line">    queue.start<span class="literal">()</span>;  </span><br><span class="line">    return queue;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>可以看到，这里在第10行判断如果stack是等于null的，则去创建一个HttpStack对象，这里会判断如果手机系统版本号是大于9的，则创建一个HurlStack的实例，否则就创建一个HttpClientStack的实例。实际上HurlStack的内部就是使用HttpURLConnection进行网络通讯的，而HttpClientStack的内部则是使用HttpClient进行网络通讯的，这里为什么这样选择呢？可以参考我之前翻译的一篇文章<a target="_blank" rel="noopener" href="http://blog.csdn.net/guolin_blog/article/details/12452307">Android访问网络，使用HttpURLConnection还是HttpClient？</a></p>
<p>创建好了HttpStack之后，接下来又创建了一个Network对象，它是用于根据传入的HttpStack对象来处理网络请求的，紧接着new出一个RequestQueue对象，并调用它的start()方法进行启动，然后将RequestQueue返回，这样newRequestQueue()的方法就执行结束了。</p>
<p>那么RequestQueue的start()方法内部到底执行了什么东西呢？我们跟进去瞧一瞧：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span>()</span> &#123;  </span><br><span class="line">    stop();  <span class="comment">// Make sure any currently running dispatchers are stopped.  </span></span><br><span class="line">    <span class="comment">// Create the cache dispatcher and start it.  </span></span><br><span class="line">    mCacheDispatcher = <span class="keyword">new</span> CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);  </span><br><span class="line">    mCacheDispatcher.start();  </span><br><span class="line">    <span class="comment">// Create network dispatchers (and corresponding threads) up to the pool size.  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; mDispatchers.length; i++) &#123;  </span><br><span class="line">        NetworkDispatcher networkDispatcher = <span class="keyword">new</span> NetworkDispatcher(mNetworkQueue, mNetwork,  </span><br><span class="line">                mCache, mDelivery);  </span><br><span class="line">        mDispatchers[i] = networkDispatcher;  </span><br><span class="line">        networkDispatcher.start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>这里先是创建了一个CacheDispatcher的实例，然后调用了它的start()方法，接着在一个for循环里去创建NetworkDispatcher的实例，并分别调用它们的start()方法。这里的CacheDispatcher和NetworkDispatcher都是继承自Thread的，而默认情况下for循环会执行四次，也就是说当调用了Volley.newRequestQueue(context)之后，就会有五个线程一直在后台运行，不断等待网络请求的到来，其中CacheDispatcher是缓存线程，NetworkDispatcher是网络请求线程。</p>
<p>得到了RequestQueue之后，我们只需要构建出相应的Request，然后调用RequestQueue的add()方法将Request传入就可以完成网络请求操作了，那么不用说，add()方法的内部肯定有着非常复杂的逻辑，我们来一起看一下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Request&lt;T&gt; <span class="title">add</span>(<span class="params">Request&lt;T&gt; request</span>)</span> &#123;  </span><br><span class="line">    <span class="comment">// Tag the request as belonging to this queue and add it to the set of current requests.  </span></span><br><span class="line">    request.setRequestQueue(<span class="keyword">this</span>);  </span><br><span class="line">    synchronized (mCurrentRequests) &#123;  </span><br><span class="line">        mCurrentRequests.<span class="keyword">add</span>(request);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// Process requests in the order they are added.  </span></span><br><span class="line">    request.setSequence(getSequenceNumber());  </span><br><span class="line">    request.addMarker(<span class="string">&quot;add-to-queue&quot;</span>);  </span><br><span class="line">    <span class="comment">// If the request is uncacheable, skip the cache queue and go straight to the network.  </span></span><br><span class="line">    <span class="keyword">if</span> (!request.shouldCache()) &#123;  </span><br><span class="line">        mNetworkQueue.<span class="keyword">add</span>(request);  </span><br><span class="line">        <span class="keyword">return</span> request;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// Insert request into stage if there&#x27;s already a request with the same cache key in flight.  </span></span><br><span class="line">    synchronized (mWaitingRequests) &#123;  </span><br><span class="line">        String cacheKey = request.getCacheKey();  </span><br><span class="line">        <span class="keyword">if</span> (mWaitingRequests.containsKey(cacheKey)) &#123;  </span><br><span class="line">            <span class="comment">// There is already a request in flight. Queue up.  </span></span><br><span class="line">            Queue&lt;Request&lt;?&gt;&gt; stagedRequests = mWaitingRequests.<span class="keyword">get</span>(cacheKey);  </span><br><span class="line">            <span class="keyword">if</span> (stagedRequests == <span class="literal">null</span>) &#123;  </span><br><span class="line">                stagedRequests = <span class="keyword">new</span> LinkedList&lt;Request&lt;?&gt;&gt;();  </span><br><span class="line">            &#125;  </span><br><span class="line">            stagedRequests.<span class="keyword">add</span>(request);  </span><br><span class="line">            mWaitingRequests.put(cacheKey, stagedRequests);  </span><br><span class="line">            <span class="keyword">if</span> (VolleyLog.DEBUG) &#123;  </span><br><span class="line">                VolleyLog.v(<span class="string">&quot;Request for cacheKey=%s is in flight, putting on hold.&quot;</span>, cacheKey);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="comment">// Insert &#x27;null&#x27; queue for this cacheKey, indicating there is now a request in  </span></span><br><span class="line">            <span class="comment">// flight.  </span></span><br><span class="line">            mWaitingRequests.put(cacheKey, <span class="literal">null</span>);  </span><br><span class="line">            mCacheQueue.<span class="keyword">add</span>(request);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> request;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>可以看到，在第11行的时候会判断当前的请求是否可以缓存，如果不能缓存则在第12行直接将这条请求加入网络请求队列，可以缓存的话则在第33行将这条请求加入缓存队列。在默认情况下，每条请求都是可以缓存的，当然我们也可以调用Request的setShouldCache(false)方法来改变这一默认行为。</p>
<p>OK，那么既然默认每条请求都是可以缓存的，自然就被添加到了缓存队列中，于是一直在后台等待的缓存线程就要开始运行起来了，我们看下CacheDispatcher中的run()方法，代码如下所示：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CacheDispatcher</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    ……  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        <span class="keyword">if</span> (<span class="type">DEBUG</span>) <span class="type">VolleyLog</span>.v(<span class="string">&quot;start new dispatcher&quot;</span>);  </span><br><span class="line">        <span class="type">Process</span>.setThreadPriority(<span class="type">Process</span>.<span class="type">THREAD_PRIORITY_BACKGROUND</span>);  </span><br><span class="line">        <span class="comment">// Make a blocking call to initialize the cache.  </span></span><br><span class="line">        mCache.initialize();  </span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                <span class="comment">// Get a request from the cache triage queue, blocking until  </span></span><br><span class="line">                <span class="comment">// at least one is available.  </span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">Request</span>&lt;?&gt; request = mCacheQueue.take();  </span><br><span class="line">                request.addMarker(<span class="string">&quot;cache-queue-take&quot;</span>);  </span><br><span class="line">                <span class="comment">// If the request has been canceled, don&#x27;t bother dispatching it.  </span></span><br><span class="line">                <span class="keyword">if</span> (request.isCanceled()) &#123;  </span><br><span class="line">                    request.finish(<span class="string">&quot;cache-discard-canceled&quot;</span>);  </span><br><span class="line">                    <span class="keyword">continue</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="comment">// Attempt to retrieve this item from cache.  </span></span><br><span class="line">                <span class="type">Cache</span>.<span class="type">Entry</span> entry = mCache.get(request.getCacheKey());  </span><br><span class="line">                <span class="keyword">if</span> (entry == <span class="literal">null</span>) &#123;  </span><br><span class="line">                    request.addMarker(<span class="string">&quot;cache-miss&quot;</span>);  </span><br><span class="line">                    <span class="comment">// Cache miss; send off to the network dispatcher.  </span></span><br><span class="line">                    mNetworkQueue.put(request);  </span><br><span class="line">                    <span class="keyword">continue</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="comment">// If it is completely expired, just send it to the network.  </span></span><br><span class="line">                <span class="keyword">if</span> (entry.isExpired()) &#123;  </span><br><span class="line">                    request.addMarker(<span class="string">&quot;cache-hit-expired&quot;</span>);  </span><br><span class="line">                    request.setCacheEntry(entry);  </span><br><span class="line">                    mNetworkQueue.put(request);  </span><br><span class="line">                    <span class="keyword">continue</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="comment">// We have a cache hit; parse its data for delivery back to the request.  </span></span><br><span class="line">                request.addMarker(<span class="string">&quot;cache-hit&quot;</span>);  </span><br><span class="line">                <span class="type">Response</span>&lt;?&gt; response = request.parseNetworkResponse(  </span><br><span class="line">                        <span class="keyword">new</span> <span class="type">NetworkResponse</span>(entry.data, entry.responseHeaders));  </span><br><span class="line">                request.addMarker(<span class="string">&quot;cache-hit-parsed&quot;</span>);  </span><br><span class="line">                <span class="keyword">if</span> (!entry.refreshNeeded()) &#123;  </span><br><span class="line">                    <span class="comment">// Completely unexpired cache hit. Just deliver the response.  </span></span><br><span class="line">                    mDelivery.postResponse(request, response);  </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                    <span class="comment">// Soft-expired cache hit. We can deliver the cached response,  </span></span><br><span class="line">                    <span class="comment">// but we need to also send the request to the network for  </span></span><br><span class="line">                    <span class="comment">// refreshing.  </span></span><br><span class="line">                    request.addMarker(<span class="string">&quot;cache-hit-refresh-needed&quot;</span>);  </span><br><span class="line">                    request.setCacheEntry(entry);  </span><br><span class="line">                    <span class="comment">// Mark the response as intermediate.  </span></span><br><span class="line">                    response.intermediate = <span class="literal">true</span>;  </span><br><span class="line">                    <span class="comment">// Post the intermediate response back to the user and have  </span></span><br><span class="line">                    <span class="comment">// the delivery then forward the request along to the network.  </span></span><br><span class="line">                    mDelivery.postResponse(request, response, <span class="keyword">new</span> <span class="type">Runnable</span>() &#123;  </span><br><span class="line">                        <span class="meta">@Override</span>  </span><br><span class="line">                        public void run() &#123;  </span><br><span class="line">                            <span class="keyword">try</span> &#123;  </span><br><span class="line">                                mNetworkQueue.put(request);  </span><br><span class="line">                            &#125; <span class="keyword">catch</span> (<span class="type">InterruptedException</span> e) &#123;  </span><br><span class="line">                                <span class="comment">// Not much we can do about this.  </span></span><br><span class="line">                            &#125;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (<span class="type">InterruptedException</span> e) &#123;  </span><br><span class="line">                <span class="comment">// We may have been interrupted because it was time to quit.  </span></span><br><span class="line">                <span class="keyword">if</span> (mQuit) &#123;  </span><br><span class="line">                    <span class="keyword">return</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">continue</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>代码有点长，我们只挑重点看。首先在11行可以看到一个while(true)循环，说明缓存线程始终是在运行的，接着在第23行会尝试从缓存当中取出响应结果，如何为空的话则把这条请求加入到网络请求队列中，如果不为空的话再判断该缓存是否已过期，如果已经过期了则同样把这条请求加入到网络请求队列中，否则就认为不需要重发网络请求，直接使用缓存中的数据即可。之后会在第39行调用Request的parseNetworkResponse()方法来对数据进行解析，再往后就是将解析出来的数据进行回调了，这部分代码我们先跳过，因为它的逻辑和NetworkDispatcher后半部分的逻辑是基本相同的，那么我们等下合并在一起看就好了，先来看一下NetworkDispatcher中是怎么处理网络请求队列的，代码如下所示：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> NetworkDispatcher extends Thread &#123;  </span><br><span class="line">    ……  </span><br><span class="line">    @Override  </span><br><span class="line">    public void run<span class="literal">()</span> &#123;  </span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Process</span>.</span></span>set<span class="constructor">ThreadPriority(Process.THREAD_PRIORITY_BACKGROUND)</span>;  </span><br><span class="line">        Request&lt;?&gt; request;  </span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                <span class="comment">// Take a request from the queue.  </span></span><br><span class="line">                request = mQueue.take<span class="literal">()</span>;  </span><br><span class="line">            &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">                <span class="comment">// We may have been interrupted because it was time to quit.  </span></span><br><span class="line">                <span class="keyword">if</span> (mQuit) &#123;  </span><br><span class="line">                    return;  </span><br><span class="line">                &#125;  </span><br><span class="line">                continue;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                request.add<span class="constructor">Marker(<span class="string">&quot;network-queue-take&quot;</span>)</span>;  </span><br><span class="line">                <span class="comment">// If the request was cancelled already, do not perform the  </span></span><br><span class="line">                <span class="comment">// network request.  </span></span><br><span class="line">                <span class="keyword">if</span> (request.is<span class="constructor">Canceled()</span>) &#123;  </span><br><span class="line">                    request.finish(<span class="string">&quot;network-discard-cancelled&quot;</span>);  </span><br><span class="line">                    continue;  </span><br><span class="line">                &#125;  </span><br><span class="line">                add<span class="constructor">TrafficStatsTag(<span class="params">request</span>)</span>;  </span><br><span class="line">                <span class="comment">// Perform the network request.  </span></span><br><span class="line">                NetworkResponse networkResponse = mNetwork.perform<span class="constructor">Request(<span class="params">request</span>)</span>;  </span><br><span class="line">                request.add<span class="constructor">Marker(<span class="string">&quot;network-http-complete&quot;</span>)</span>;  </span><br><span class="line">                <span class="comment">// If the server returned 304 AND we delivered a response already,  </span></span><br><span class="line">                <span class="comment">// we&#x27;re done -- don&#x27;t deliver a second identical response.  </span></span><br><span class="line">                <span class="keyword">if</span> (networkResponse.notModified<span class="operator"> &amp;&amp; </span>request.has<span class="constructor">HadResponseDelivered()</span>) &#123;  </span><br><span class="line">                    request.finish(<span class="string">&quot;not-modified&quot;</span>);  </span><br><span class="line">                    continue;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="comment">// Parse the response here on the worker thread.  </span></span><br><span class="line">                Response&lt;?&gt; response = request.parse<span class="constructor">NetworkResponse(<span class="params">networkResponse</span>)</span>;  </span><br><span class="line">                request.add<span class="constructor">Marker(<span class="string">&quot;network-parse-complete&quot;</span>)</span>;  </span><br><span class="line">                <span class="comment">// Write to cache if applicable.  </span></span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> Only update cache metadata instead of entire record for 304s.  </span></span><br><span class="line">                <span class="keyword">if</span> (request.should<span class="constructor">Cache()</span><span class="operator"> &amp;&amp; </span>response.cacheEntry != null) &#123;  </span><br><span class="line">                    mCache.put(request.get<span class="constructor">CacheKey()</span>, response.cacheEntry);  </span><br><span class="line">                    request.add<span class="constructor">Marker(<span class="string">&quot;network-cache-written&quot;</span>)</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="comment">// Post the response back.  </span></span><br><span class="line">                request.mark<span class="constructor">Delivered()</span>;  </span><br><span class="line">                mDelivery.post<span class="constructor">Response(<span class="params">request</span>, <span class="params">response</span>)</span>;  </span><br><span class="line">            &#125; catch (VolleyError volleyError) &#123;  </span><br><span class="line">                parse<span class="constructor">AndDeliverNetworkError(<span class="params">request</span>, <span class="params">volleyError</span>)</span>;  </span><br><span class="line">            &#125; catch (Exception e) &#123;  </span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">VolleyLog</span>.</span></span>e(e, <span class="string">&quot;Unhandled exception %s&quot;</span>, e.<span class="keyword">to</span><span class="constructor">String()</span>);  </span><br><span class="line">                mDelivery.post<span class="constructor">Error(<span class="params">request</span>, <span class="params">new</span> VolleyError(<span class="params">e</span>)</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>同样地，在第7行我们看到了类似的while(true)循环，说明网络请求线程也是在不断运行的。在第28行的时候会调用Network的performRequest()方法来去发送网络请求，而Network是一个接口，这里具体的实现是BasicNetwork，我们来看下它的performRequest()方法，如下所示：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicNetwork</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">Network</span></span> </span>&#123;  </span><br><span class="line">    ……  </span><br><span class="line">    @Override  </span><br><span class="line">    <span class="keyword">public</span> NetworkResponse performRequest(Request&lt;?&gt; request) throws VolleyError &#123;  </span><br><span class="line">        long requestStart = SystemClock.elapsedRealtime();  </span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;  </span><br><span class="line">            HttpResponse httpResponse = <span class="literal">null</span>;  </span><br><span class="line">            byte[] responseContents = <span class="literal">null</span>;  </span><br><span class="line">            Map&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; responseHeaders = <span class="keyword">new</span> <span class="type">HashMap</span>&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt;();  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                <span class="comment">// Gather headers.  </span></span><br><span class="line">                Map&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; headers = <span class="keyword">new</span> <span class="type">HashMap</span>&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt;();  </span><br><span class="line">                addCacheHeaders(headers, request.getCacheEntry());  </span><br><span class="line">                httpResponse = mHttpStack.performRequest(request, headers);  </span><br><span class="line">                StatusLine statusLine = httpResponse.getStatusLine();  </span><br><span class="line">                int statusCode = statusLine.getStatusCode();  </span><br><span class="line">                responseHeaders = convertHeaders(httpResponse.getAllHeaders());  </span><br><span class="line">                <span class="comment">// Handle cache validation.  </span></span><br><span class="line">                <span class="keyword">if</span> (statusCode == HttpStatus.SC_NOT_MODIFIED) &#123;  </span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">NetworkResponse</span>(HttpStatus.SC_NOT_MODIFIED,  </span><br><span class="line">                            request.getCacheEntry() == <span class="literal">null</span> ? <span class="literal">null</span> : <span class="type">request</span>.getCacheEntry().data,  </span><br><span class="line">                            responseHeaders, <span class="literal">true</span>);  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="comment">// Some responses such as 204s do not have content.  We must check.  </span></span><br><span class="line">                <span class="keyword">if</span> (httpResponse.getEntity() != <span class="literal">null</span>) &#123;  </span><br><span class="line">                  responseContents = entityToBytes(httpResponse.getEntity());  </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                  <span class="comment">// Add 0 byte response as a way of honestly representing a  </span></span><br><span class="line">                  <span class="comment">// no-content request.  </span></span><br><span class="line">                  responseContents = <span class="keyword">new</span> <span class="type">byte</span>[<span class="number">0</span>];  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="comment">// if the request is slow, log it.  </span></span><br><span class="line">                long requestLifetime = SystemClock.elapsedRealtime() - requestStart;  </span><br><span class="line">                logSlowRequests(requestLifetime, request, responseContents, statusLine);  </span><br><span class="line">                <span class="keyword">if</span> (statusCode &lt; <span class="number">200</span> || statusCode &gt; <span class="number">299</span>) &#123;  </span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IOException</span>();  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">NetworkResponse</span>(statusCode, responseContents, responseHeaders, <span class="literal">false</span>);  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">                ……  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>这段方法中大多都是一些网络请求细节方面的东西，我们并不需要太多关心，需要注意的是在第14行调用了HttpStack的performRequest()方法，这里的HttpStack就是在一开始调用newRequestQueue()方法是创建的实例，默认情况下如果系统版本号大于9就创建的HurlStack对象，否则创建HttpClientStack对象。前面已经说过，这两个对象的内部实际就是分别使用HttpURLConnection和HttpClient来发送网络请求的，我们就不再跟进去阅读了，之后会将服务器返回的数据组装成一个NetworkResponse对象进行返回。</p>
<p>在NetworkDispatcher中收到了NetworkResponse这个返回值后又会调用Request的parseNetworkResponse()方法来解析NetworkResponse中的数据，以及将数据写入到缓存，这个方法的实现是交给Request的子类来完成的，因为不同种类的Request解析的方式也肯定不同。还记得我们在上一篇文章中学习的自定义Request的方式吗？其中parseNetworkResponse()这个方法就是必须要重写的。</p>
<p>在解析完了NetworkResponse中的数据之后，又会调用ExecutorDelivery的postResponse()方法来回调解析出的数据，代码如下所示：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void post<span class="constructor">Response(Request&lt;?&gt; <span class="params">request</span>, Response&lt;?&gt; <span class="params">response</span>, Runnable <span class="params">runnable</span>)</span> &#123;  </span><br><span class="line">    request.mark<span class="constructor">Delivered()</span>;  </span><br><span class="line">    request.add<span class="constructor">Marker(<span class="string">&quot;post-response&quot;</span>)</span>;  </span><br><span class="line">    mResponsePoster.execute(<span class="keyword">new</span> <span class="constructor">ResponseDeliveryRunnable(<span class="params">request</span>, <span class="params">response</span>, <span class="params">runnable</span>)</span>);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>其中，在mResponsePoster的execute()方法中传入了一个ResponseDeliveryRunnable对象，就可以保证该对象中的run()方法就是在主线程当中运行的了，我们看下run()方法中的代码是什么样的：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseDeliveryRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Request mRequest;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Response mResponse;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable mRunnable;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResponseDeliveryRunnable</span><span class="params">(Request request, Response response, Runnable runnable)</span> </span>&#123;  </span><br><span class="line">        mRequest = request;  </span><br><span class="line">        mResponse = response;  </span><br><span class="line">        mRunnable = runnable;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">&quot;unchecked&quot;</span>)  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// If this request has canceled, finish it and don&#x27;t deliver.  </span></span><br><span class="line">        <span class="keyword">if</span> (mRequest.isCanceled()) &#123;  </span><br><span class="line">            mRequest.finish(<span class="string">&quot;canceled-at-delivery&quot;</span>);  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// Deliver a normal response or error, depending.  </span></span><br><span class="line">        <span class="keyword">if</span> (mResponse.isSuccess()) &#123;  </span><br><span class="line">            mRequest.deliverResponse(mResponse.result);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            mRequest.deliverError(mResponse.<span class="keyword">error</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// If this is an intermediate response, add a marker, otherwise we&#x27;re done  </span></span><br><span class="line">        <span class="comment">// and the request can be finished.  </span></span><br><span class="line">        <span class="keyword">if</span> (mResponse.intermediate) &#123;  </span><br><span class="line">            mRequest.addMarker(<span class="string">&quot;intermediate-response&quot;</span>);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            mRequest.finish(<span class="string">&quot;done&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// If we have been provided a post-delivery runnable, run it.  </span></span><br><span class="line">        <span class="keyword">if</span> (mRunnable != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            mRunnable.run();  </span><br><span class="line">        &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>代码虽然不多，但我们并不需要行行阅读，抓住重点看即可。其中在第22行调用了Request的deliverResponse()方法，有没有感觉很熟悉？没错，这个就是我们在自定义Request时需要重写的另外一个方法，每一条网络请求的响应都是回调到这个方法中，最后我们再在这个方法中将响应的数据回调到Response.Listener的onResponse()方法中就可以了。</p>
<p>好了，到这里我们就把Volley的完整执行流程全部梳理了一遍，你是不是已经感觉已经很清晰了呢？对了，还记得在文章一开始的那张流程图吗，刚才还不能理解，现在我们再来重新看下这张图：<br><img src="/images/Volley%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90%E5%9B%9B%E5%B8%A6%E4%BD%A0%E4%BB%8E%E6%BA%90%E7%A0%81%E7%9A%84%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3Volley/1.jpg"></p>
<p>其中蓝色部分代表主线程，绿色部分代表缓存线程，橙色部分代表网络线程。我们在主线程中调用RequestQueue的add()方法来添加一条网络请求，这条请求会先被加入到缓存队列当中，如果发现可以找到相应的缓存结果就直接读取缓存并解析，然后回调给主线程。如果在缓存中没有找到结果，则将这条请求加入到网络请求队列中，然后处理发送HTTP请求，解析响应结果，写入缓存，并回调主线程。</p>
<p>怎么样，是不是感觉现在理解这张图已经变得轻松简单了？好了，到此为止我们就把Volley的用法和源码全部学习完了，相信你已经对Volley非常熟悉并可以将它应用到实际项目当中了，那么Volley完全解析系列的文章到此结束，感谢大家有耐心看到最后。</p>
<blockquote>
<p>转载请注明出处：<a target="_blank" rel="noopener" href="http://blog.csdn.net/guolin_blog/article/details/17656437">http://blog.csdn.net/guolin_blog/article/details/17656437</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://moqiang02.github.io/2015/08/12/Android-Volley%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90-%E5%9B%9B-%EF%BC%8C%E5%B8%A6%E4%BD%A0%E4%BB%8E%E6%BA%90%E7%A0%81%E7%9A%84%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3Volley/" data-id="cla0v65rd002ug0v11wy4h26t" data-title="Android Volley完全解析(四)，带你从源码的角度理解Volley" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android%E5%BC%80%E6%BA%90/" rel="tag">Android开源</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/08/12/%E6%9C%80%E6%96%B0Volley%E6%A1%86%E6%9E%B6%E7%9A%84JAR%E6%96%87%E4%BB%B6%E7%94%9F%E6%88%90/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          最新Volley框架的JAR文件生成
        
      </div>
    </a>
  
  
    <a href="/2015/08/12/Android-Volley%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90-%E4%B8%89-%EF%BC%8C%E5%AE%9A%E5%88%B6%E8%87%AA%E5%B7%B1%E7%9A%84Request/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">Android Volley完全解析(三)，定制自己的Request</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/android/">android</a><span class="category-list-count">255</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/apache/">apache</a><span class="category-list-count">27</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/flutter/">flutter</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/github%E5%8D%9A%E5%AE%A2/">github博客</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/go/">go</a><span class="category-list-count">26</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/html-css/">html+css</a><span class="category-list-count">24</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iis/">iis</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">63</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/">javascript</a><span class="category-list-count">114</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/kotlin/">kotlin</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">68</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mac/">mac</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/memcached/">memcached</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mongodb/">mongodb</a><span class="category-list-count">19</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a><span class="category-list-count">72</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/">nginx</a><span class="category-list-count">41</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/nodejs/">nodejs</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/php/">php</a><span class="category-list-count">185</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a><span class="category-list-count">44</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%B6%E5%AE%83/">其它</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a><span class="category-list-count">51</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/">开源项目</a><span class="category-list-count">73</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/">生活随笔</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93/">量化交易</a><span class="category-list-count">3</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/AndroidStudio/" style="font-size: 13.75px;">AndroidStudio</a> <a href="/tags/AndroidUI/" style="font-size: 20px;">AndroidUI</a> <a href="/tags/Android%E4%BA%8B%E4%BB%B6%E6%8B%A6%E6%88%AA/" style="font-size: 11.25px;">Android事件拦截</a> <a href="/tags/Android%E5%BC%80%E6%BA%90/" style="font-size: 18.13px;">Android开源</a> <a href="/tags/CI/" style="font-size: 15.63px;">CI</a> <a href="/tags/CURL/" style="font-size: 13.13px;">CURL</a> <a href="/tags/DEDE/" style="font-size: 18.75px;">DEDE</a> <a href="/tags/Docker/" style="font-size: 15px;">Docker</a> <a href="/tags/Flask/" style="font-size: 10.63px;">Flask</a> <a href="/tags/JavaSE/" style="font-size: 18.13px;">JavaSE</a> <a href="/tags/Laravel/" style="font-size: 18.13px;">Laravel</a> <a href="/tags/Maven/" style="font-size: 10.63px;">Maven</a> <a href="/tags/SVN/" style="font-size: 10px;">SVN</a> <a href="/tags/SpringBoot/" style="font-size: 19.38px;">SpringBoot</a> <a href="/tags/Thinkphp/" style="font-size: 10px;">Thinkphp</a> <a href="/tags/UEditor/" style="font-size: 11.88px;">UEditor</a> <a href="/tags/VMware/" style="font-size: 12.5px;">VMware</a> <a href="/tags/Vue/" style="font-size: 18.13px;">Vue</a> <a href="/tags/WebSocket/" style="font-size: 13.13px;">WebSocket</a> <a href="/tags/ecshop/" style="font-size: 15px;">ecshop</a> <a href="/tags/scrapy/" style="font-size: 14.38px;">scrapy</a> <a href="/tags/smarty/" style="font-size: 12.5px;">smarty</a> <a href="/tags/socket/" style="font-size: 15px;">socket</a> <a href="/tags/sphinx/" style="font-size: 11.88px;">sphinx</a> <a href="/tags/vagrant/" style="font-size: 12.5px;">vagrant</a> <a href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" style="font-size: 11.25px;">微服务</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/" style="font-size: 15.63px;">数据传输</a> <a href="/tags/%E6%AD%A3%E5%88%99/" style="font-size: 11.88px;">正则</a> <a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size: 16.25px;">消息队列</a> <a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size: 16.88px;">爬虫</a> <a href="/tags/%E9%9B%86%E7%BE%A4/" style="font-size: 17.5px;">集群</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/11/27/Java%E6%95%99%E7%A8%8B%E7%B4%A2%E5%BC%95/">Java教程索引</a>
          </li>
        
          <li>
            <a href="/2022/11/23/Spring-Boot-Event-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%8C%E8%BD%BB%E6%9D%BE%E5%AE%9E%E7%8E%B0%E4%B8%9A%E5%8A%A1%E8%A7%A3%E8%80%A6/">SpringBoot Event 观察者模式，轻松实现业务解耦</a>
          </li>
        
          <li>
            <a href="/2022/11/22/SpringBoot-Redis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88Stream%E5%AE%9E%E7%8E%B0%EF%BC%89/">SpringBoot Redis消息队列（Stream实现）</a>
          </li>
        
          <li>
            <a href="/2022/11/20/SpringBoot%E6%B3%A8%E8%A7%A3%E4%B9%8B-Configuration%E3%80%81-Bean%E3%80%81-Component/">SpringBoot注解之@Configuration、@Bean、@Component</a>
          </li>
        
          <li>
            <a href="/2022/11/15/SpringBoot%E6%8E%A5%E6%94%B6%E8%AF%B7%E6%B1%82%E7%9A%84N%E7%A7%8D%E5%A7%BF%E5%8A%BF/">SpringBoot接收请求的N种姿势</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 moqiang<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>

<!-- rex -->

<script src="/js/toc.js"></script>


  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>