<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>深入浅出RxJava | 自强不息</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="一、基础篇RxJava正在Android开发者中变的越来越流行。唯一的问题就是上手不容易，尤其是大部分人之前都是使用命令式编程语言。但是一旦你弄明白了，你就会发现RxJava真是太棒了。这里仅仅是帮助你了解RxJava，整个系列共有四篇文章，希望你看完这四篇文章之后能够了解RxJava背后的思想，并且喜欢上RxJava。">
<meta property="og:type" content="article">
<meta property="og:title" content="深入浅出RxJava">
<meta property="og:url" content="http://moqiang02.github.io/2016/04/23/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BARxJava/index.html">
<meta property="og:site_name" content="自强不息">
<meta property="og:description" content="一、基础篇RxJava正在Android开发者中变的越来越流行。唯一的问题就是上手不容易，尤其是大部分人之前都是使用命令式编程语言。但是一旦你弄明白了，你就会发现RxJava真是太棒了。这里仅仅是帮助你了解RxJava，整个系列共有四篇文章，希望你看完这四篇文章之后能够了解RxJava背后的思想，并且喜欢上RxJava。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2016-04-23T15:23:22.000Z">
<meta property="article:modified_time" content="2022-10-26T09:28:54.152Z">
<meta property="article:author" content="moqiang">
<meta property="article:tag" content="Android开源">
<meta name="twitter:card" content="summary">
  
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">自强不息</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://moqiang02.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-深入浅出RxJava" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2016/04/23/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BARxJava/" class="article-date">
  <time class="dt-published" datetime="2016-04-23T15:23:22.000Z" itemprop="datePublished">2016-04-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/android/">android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      深入浅出RxJava
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      

          <!-- rex -->
          
            <!-- 文章目录开始 -->
            
              <div id="toc" class="toc-article">
              <strong class="toc-title" style="cursor:pointer">目录</strong>
              <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E7%AF%87"><span class="toc-number">1.</span> <span class="toc-text">一、基础篇</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-number">1.1.</span> <span class="toc-text">基础</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E6%8D%A2"><span class="toc-number">1.2.</span> <span class="toc-text">变换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88Operators%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">操作符（Operators）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%BF%9B%E9%98%B6"><span class="toc-number">1.4.</span> <span class="toc-text">map操作符进阶</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E6%9C%8D%EF%BC%9F"><span class="toc-number">1.5.</span> <span class="toc-text">不服？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">2.</span> <span class="toc-text">二、操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="toc-number">2.1.</span> <span class="toc-text">准备工作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B"><span class="toc-number">2.2.</span> <span class="toc-text">改进</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%98%E5%8F%AF%E4%BB%A5%E6%9B%B4%E5%A5%BD"><span class="toc-number">2.3.</span> <span class="toc-text">还可以更好</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B0%E5%AF%8C%E7%9A%84%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">2.4.</span> <span class="toc-text">丰富的操作符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%84%9F%E8%A7%89%E5%A6%82%E4%BD%95%EF%BC%9F"><span class="toc-number">2.5.</span> <span class="toc-text">感觉如何？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">3.</span> <span class="toc-text">三、响应式的好处</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">3.1.</span> <span class="toc-text">错误处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">3.2.</span> <span class="toc-text">调度器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A2%E9%98%85%EF%BC%88Subscriptions%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">订阅（Subscriptions）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%9C%A8Android%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">四、在Android中使用响应式编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RxAndroid"><span class="toc-number">4.1.</span> <span class="toc-text">RxAndroid</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Retrofit"><span class="toc-number">4.2.</span> <span class="toc-text">Retrofit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%97%E7%95%99%E4%BB%A3%E7%A0%81%EF%BC%8C%E8%BF%90%E8%A1%8C%E6%9E%81%E6%85%A2%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">4.3.</span> <span class="toc-text">遗留代码，运行极慢的代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">4.4.</span> <span class="toc-text">生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">4.5.</span> <span class="toc-text">总结</span></a></li></ol></li></ol>
              </div>
            
            <!-- 文章目录结束 -->	  
          

        <h3 id="一、基础篇"><a href="#一、基础篇" class="headerlink" title="一、基础篇"></a>一、基础篇</h3><p>RxJava正在Android开发者中变的越来越流行。唯一的问题就是上手不容易，尤其是大部分人之前都是使用命令式编程语言。但是一旦你弄明白了，你就会发现RxJava真是太棒了。<br>这里仅仅是帮助你了解RxJava，整个系列共有四篇文章，希望你看完这四篇文章之后能够了解RxJava背后的思想，并且喜欢上RxJava。<span id="more"></span></p>
<h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><p>RxJava最核心的两个东西是Observables（被观察者，事件源）和Subscribers（观察者）。Observables发出一系列事件，Subscribers处理这些事件。这里的事件可以是任何你感兴趣的东西（触摸事件，web接口调用返回的数据。。。）</p>
<p>一个Observable可以发出零个或者多个事件，知道结束或者出错。每发出一个事件，就会调用它的Subscriber的onNext方法，最后调用<code>Subscriber.onNext()</code>或者<code>Subscriber.onError()</code>结束。</p>
<p>Rxjava的看起来很想设计模式中的观察者模式，但是有一点明显不同，那就是如果一个Observerble没有任何的的Subscriber，那么这个Observable是不会发出任何事件的。</p>
<p><strong>Hello World</strong><br>创建一个Observable对象很简单，直接调用Observable.create即可</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Observable</span>&lt;<span class="title class_">String</span>&gt; myObservable = <span class="title class_">Observable</span>.<span class="title function_">create</span>(  </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Observable</span>.<span class="property">OnSubscribe</span>&lt;<span class="title class_">String</span>&gt;() &#123;  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">call</span>(<span class="params">Subscriber&lt;? <span class="variable language_">super</span> <span class="built_in">String</span>&gt; sub</span>) &#123;  </span><br><span class="line">            sub.<span class="title function_">onNext</span>(<span class="string">&quot;Hello, world!&quot;</span>);  </span><br><span class="line">            sub.<span class="title function_">onCompleted</span>();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">);  </span><br></pre></td></tr></table></figure>
<p>这里定义的Observable对象仅仅发出一个Hello World字符串，然后就结束了。接着我们创建一个Subscriber来处理Observable对象发出的字符串。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Subscriber</span>&lt;<span class="title class_">String</span>&gt; mySubscriber = <span class="keyword">new</span> <span class="title class_">Subscriber</span>&lt;<span class="title class_">String</span>&gt;() &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">onNext</span>(<span class="params"><span class="built_in">String</span> s</span>) &#123; <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(s); &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">onCompleted</span>(<span class="params"></span>) &#123; &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">onError</span>(<span class="params">Throwable e</span>) &#123; &#125;  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>
<p>这里subscriber仅仅就是打印observable发出的字符串。通过subscribe函数就可以将我们定义的myObservable对象和mySubscriber对象关联起来，这样就完成了subscriber对observable的订阅。<br><code>myObservable.subscribe(mySubscriber); </code> </p>
<p>一旦mySubscriber订阅了myObservable，myObservable就是调用mySubscriber对象的onNext和onComplete方法，mySubscriber就会打印出Hello World！</p>
<p><strong>更简洁的代码</strong><br>是不是觉得仅仅为了打印一个hello world要写这么多代码太啰嗦？我这里主要是为了展示RxJava背后的原理而采用了这种比较啰嗦的写法，RxJava其实提供了很多便捷的函数来帮助我们减少代码。</p>
<p>首先来看看如何简化Observable对象的创建过程。RxJava内置了很多简化创建Observable对象的函数，比如Observable.just就是用来创建只发出一个事件就结束的Observable对象，上面创建Observable对象的代码可以简化为一行<br><code>Observable&lt;String&gt; myObservable = Observable.just(&quot;Hello, world!&quot;);</code></p>
<p>接下来看看如何简化Subscriber，上面的例子中，我们其实并不关心OnComplete和OnError，我们只需要在onNext的时候做一些处理，这时候就可以使用Action1类。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Action1</span>&lt;<span class="title class_">String</span>&gt; onNextAction = <span class="keyword">new</span> <span class="title class_">Action1</span>&lt;<span class="title class_">String</span>&gt;() &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">call</span>(<span class="params"><span class="built_in">String</span> s</span>) &#123;  </span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(s);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>
<p>subscribe方法有一个重载版本，接受三个Action1类型的参数，分别对应OnNext，OnComplete， OnError函数。<br><code>myObservable.subscribe(onNextAction, onErrorAction, onCompleteAction); </code> </p>
<p>这里我们并不关心onError和onComplete，所以只需要第一个参数就可以</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myObservable.subscribe(onNextAction);  </span><br><span class="line"><span class="regexp">//</span> Outputs <span class="string">&quot;Hello, world!&quot;</span>  </span><br></pre></td></tr></table></figure>
<p>上面的代码最终可以写成这样</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Observable</span>.<span class="title function_">just</span>(<span class="string">&quot;Hello, world!&quot;</span>)  </span><br><span class="line">    .<span class="title function_">subscribe</span>(<span class="keyword">new</span> <span class="title class_">Action1</span>&lt;<span class="title class_">String</span>&gt;() &#123;  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">call</span>(<span class="params"><span class="built_in">String</span> s</span>) &#123;  </span><br><span class="line">              <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(s);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;);  </span><br></pre></td></tr></table></figure>
<p>使用java8的lambda可以使代码更简洁</p>
<figure class="highlight golo"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Observable</span>.just(<span class="string">&quot;Hello, world!&quot;</span>)  </span><br><span class="line">    .subscribe(s -&gt; System.out.<span class="keyword">println</span>(s));  </span><br></pre></td></tr></table></figure>
<p>Android开发中，强烈推荐使用retrolambda这个gradle插件，这样你就可以在你的代码中使用lambda了。</p>
<h4 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h4><p>让我们做一些更有趣的事情吧！<br>比如我想在hello world中加上我的签名，你可能会想到去修改Observable对象：</p>
<figure class="highlight golo"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Observable</span>.just(<span class="string">&quot;Hello, world! -Dan&quot;</span>)  </span><br><span class="line">    .subscribe(s -&gt; System.out.<span class="keyword">println</span>(s));  </span><br></pre></td></tr></table></figure>
<p>如果你能够改变Observable对象，这当然是可以的，但是如果你不能修改Observable对象呢？比如Observable对象是第三方库提供的？比如我的Observable对象被多个Subscriber订阅，但是我只想在对某个订阅者做修改呢？<br>那么在Subscriber中对事件进行修改怎么样呢？比如下面的代码：</p>
<figure class="highlight golo"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Observable</span>.just(<span class="string">&quot;Hello, world!&quot;</span>)  </span><br><span class="line">    .subscribe(s -&gt; System.out.<span class="keyword">println</span>(s + <span class="string">&quot; -Dan&quot;</span>));  </span><br></pre></td></tr></table></figure>
<p>这种方式仍然不能让人满意，因为我希望我的Subscribers越轻量越好，因为我有可能会在mainThread中运行subscriber。另外，根据响应式函数编程的概念，Subscribers更应该做的事情是“响应”，响应Observable发出的事件，而不是去修改。如果我能在某些中间步骤中对“Hello World！”进行变换是不是很酷？</p>
<h4 id="操作符（Operators）"><a href="#操作符（Operators）" class="headerlink" title="操作符（Operators）"></a>操作符（Operators）</h4><p>操作符就是为了解决对Observable对象的变换的问题，操作符用于在Observable和最终的Subscriber之间修改Observable发出的事件。RxJava提供了很多很有用的操作符。<br>比如map操作符，就是用来把把一个事件转换为另一个事件的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Observable</span>.<span class="title function_">just</span>(<span class="string">&quot;Hello, world!&quot;</span>)  </span><br><span class="line">  .<span class="title function_">map</span>(<span class="keyword">new</span> <span class="title class_">Func1</span>&lt;<span class="title class_">String</span>, <span class="title class_">String</span>&gt;() &#123;  </span><br><span class="line">      <span class="meta">@Override</span>  </span><br><span class="line">      <span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">call</span>(<span class="params"><span class="built_in">String</span> s</span>) &#123;  </span><br><span class="line">          <span class="keyword">return</span> s + <span class="string">&quot; -Dan&quot;</span>;  </span><br><span class="line">      &#125;  </span><br><span class="line">  &#125;)  </span><br><span class="line">  .<span class="title function_">subscribe</span>(s -&gt; <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(s));  </span><br></pre></td></tr></table></figure>
<p>使用lambda可以简化为</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="string">&quot;Hello, world!&quot;</span>)  </span><br><span class="line">    .<span class="function"><span class="title">map</span>(s -&gt;</span> s + <span class="string">&quot; -Dan&quot;</span>)  </span><br><span class="line">    .<span class="function"><span class="title">subscribe</span>(s -&gt;</span> System.out.println(s));  </span><br></pre></td></tr></table></figure>
<p>是不是很酷？map()操作符就是用于变换Observable对象的，map操作符返回一个Observable对象，这样就可以实现链式调用，在一个Observable对象上多次使用map操作符，最终将最简洁的数据传递给Subscriber对象。</p>
<h4 id="map操作符进阶"><a href="#map操作符进阶" class="headerlink" title="map操作符进阶"></a>map操作符进阶</h4><p>map操作符更有趣的一点是它不必返回Observable对象返回的类型，你可以使用map操作符返回一个发出新的数据类型的observable对象。<br>比如上面的例子中，subscriber并不关心返回的字符串，而是想要字符串的hash值</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="string">&quot;Hello, world!&quot;</span>)  </span><br><span class="line">    .<span class="built_in">map</span>(<span class="literal">new</span> Func1&lt;<span class="built_in">String</span>, <span class="built_in">Integer</span>&gt;() &#123;  </span><br><span class="line">        @Override  </span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">Integer</span> call(<span class="built_in">String</span> s) &#123;  </span><br><span class="line">            <span class="keyword">return</span> s.hashCode();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;)  </span><br><span class="line">    .subscribe(i -&gt; System.out.println(<span class="built_in">Integer</span>.toString(i)));  </span><br></pre></td></tr></table></figure>
<p>很有趣吧？我们初始的Observable返回的是字符串，最终的Subscriber收到的却是Integer，当然使用lambda可以进一步简化代码：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Observable</span>.</span></span>just(<span class="string">&quot;Hello, world!&quot;</span>)  </span><br><span class="line">    .map(s -&gt; s.hash<span class="constructor">Code()</span>)  </span><br><span class="line">    .subscribe(i -&gt; <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span><span class="keyword">to</span><span class="constructor">String(<span class="params">i</span>)</span>));  </span><br></pre></td></tr></table></figure>
<p>前面说过，Subscriber做的事情越少越好，我们再增加一个map操作符</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Observable</span>.</span></span>just(<span class="string">&quot;Hello, world!&quot;</span>)  </span><br><span class="line">    .map(s -&gt; s.hash<span class="constructor">Code()</span>)  </span><br><span class="line">    .map(i -&gt; <span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span><span class="keyword">to</span><span class="constructor">String(<span class="params">i</span>)</span>)  </span><br><span class="line">    .subscribe(s -&gt; <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(s));  </span><br></pre></td></tr></table></figure>
<h4 id="不服？"><a href="#不服？" class="headerlink" title="不服？"></a>不服？</h4><p>是不是觉得我们的例子太简单，不足以说服你？你需要明白下面的两点:</p>
<p>1.Observable和Subscriber可以做任何事情<br>Observable可以是一个数据库查询，Subscriber用来显示查询结果；Observable可以是屏幕上的点击事件，Subscriber用来响应点击事件；Observable可以是一个网络请求，Subscriber用来显示请求结果。</p>
<p>2.Observable和Subscriber是独立于中间的变换过程的。<br>在Observable和Subscriber中间可以增减任何数量的map。整个系统是高度可组合的，操作数据是一个很简单的过程。</p>
<h3 id="二、操作符"><a href="#二、操作符" class="headerlink" title="二、操作符"></a>二、操作符</h3><p>在第一节中，我介绍了RxJava的一些基础知识，同时也介绍了map()操作符。当然如果你并没有意愿去使用RxJava我一点都不诧异，毕竟才接触了这么点。看完这篇blog，我相信你肯定想立即在你的项目中使用RxJava了，这篇blog将介绍许多RxJava中的操作符，RxJava的强大性就来自于它所定义的操作符。</p>
<p>首先先看一个例子：</p>
<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>假设我有这样一个方法：<br>这个方法根据输入的字符串返回一个网站的url列表（啊哈，搜索引擎）<br><code>Observable&lt;List&lt;String&gt;&gt; query(String text);</code></p>
<p>现在我希望构建一个健壮系统，它可以查询字符串并且显示结果。根据上一篇blog的内容，我们可能会写出下面的代码：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">query</span>(&quot;Hello, world!&quot;)  </span><br><span class="line">    <span class="selector-class">.subscribe</span>(urls -&gt; &#123;  </span><br><span class="line">        for (String url : urls) &#123;  </span><br><span class="line">            System<span class="selector-class">.out</span><span class="selector-class">.println</span>(url);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;);  </span><br></pre></td></tr></table></figure>
<p>这种代码当然是不能容忍的，因为上面的代码使我们丧失了变化数据流的能力。一旦我们想要更改每一个URL，只能在Subscriber中来做。我们竟然没有使用如此酷的map()操作符！！！</p>
<p>当然，我可以使用map操作符，map的输入是urls列表，处理的时候还是要for each遍历，一样很蛋疼。</p>
<p>万幸，还有Observable.from()方法，它接收一个集合作为输入，然后每次输出一个元素给subscriber：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Observable.<span class="keyword">from</span>(&quot;url1&quot;, &quot;url2&quot;, &quot;url3&quot;)  </span><br><span class="line">    .subscribe(url -&gt; <span class="keyword">System</span>.<span class="keyword">out</span>.println(url));  </span><br></pre></td></tr></table></figure>
<p>我们来把这个方法使用到刚才的场景：</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">query(<span class="string">&quot;Hello, world!&quot;</span>)  </span><br><span class="line">    .<span class="function"><span class="title">subscribe</span>(urls -&gt;</span> &#123;  </span><br><span class="line">        Observable.from(urls)  </span><br><span class="line">            .<span class="function"><span class="title">subscribe</span>(url -&gt;</span> System.out.println(url));  </span><br><span class="line">    &#125;);  </span><br></pre></td></tr></table></figure>
<p>虽然去掉了for each循环，但是代码依然看起来很乱。多个嵌套的subscription不仅看起来很丑，难以修改，更严重的是它会破坏某些我们现在还没有讲到的RxJava的特性。</p>
<h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><p>救星来了,他就是flatMap()。<br><code>Observable.flatMap()</code>接收一个Observable的输出作为输入，同时输出另外一个Observable。直接看代码：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">query</span>(<span class="string">&quot;Hello, world!&quot;</span>)  </span><br><span class="line">    .<span class="title function_">flatMap</span>(<span class="keyword">new</span> <span class="title class_">Func1</span>&lt;<span class="title class_">List</span>&lt;<span class="title class_">String</span>&gt;, <span class="title class_">Observable</span>&lt;<span class="title class_">String</span>&gt;&gt;() &#123;  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="keyword">public</span> <span class="title class_">Observable</span>&lt;<span class="title class_">String</span>&gt; <span class="title function_">call</span>(<span class="params">List&lt;<span class="built_in">String</span>&gt; urls</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">Observable</span>.<span class="title function_">from</span>(urls);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;)  </span><br><span class="line">    .<span class="title function_">subscribe</span>(url -&gt; <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(url));  </span><br></pre></td></tr></table></figure>
<p>这里我贴出了整个的函数代码，以方便你了解发生了什么，使用lambda可以大大简化代码长度：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">query(<span class="string">&quot;Hello, world!&quot;</span>)  </span><br><span class="line">    .flat<span class="constructor">Map(<span class="params">urls</span> -&gt; Observable.<span class="params">from</span>(<span class="params">urls</span>)</span>)  </span><br><span class="line">    .subscribe(url -&gt; <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(url));  </span><br></pre></td></tr></table></figure>
<p>flatMap()是不是看起来很奇怪？为什么它要返回另外一个Observable呢？理解flatMap的关键点在于，flatMap输出的新的Observable正是我们在Subscriber想要接收的。现在Subscriber不再收到<code>List&lt;String&gt;</code>，而是收到一些列单个的字符串，就像<code>Observable.from()</code>的输出一样。</p>
<p>这部分也是我当初学RxJava的时候最难理解的部分，一旦我突然领悟了，RxJava的很多疑问也就一并解决了。</p>
<h4 id="还可以更好"><a href="#还可以更好" class="headerlink" title="还可以更好"></a>还可以更好</h4><p>flatMap()实在不能更赞了，它可以返回任何它想返回的Observable对象。<br>比如下面的方法：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回网站的标题，如果404了就返回null  </span></span><br><span class="line"><span class="function">Observable&lt;<span class="type">String</span>&gt; <span class="title">getTitle</span><span class="params">(<span class="type">String</span> URL)</span></span>;  </span><br></pre></td></tr></table></figure>
<p>接着前面的例子，现在我不想打印URL了，而是要打印收到的每个网站的标题。问题来了，我的方法每次只能传入一个URL，并且返回值不是一个String，而是一个输出String的Observabl对象。使用flatMap()可以简单的解决这个问题。</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">query(<span class="string">&quot;Hello, world!&quot;</span>)  </span><br><span class="line">    .flatMap(urls -&gt; Observable.<span class="keyword">from</span>(urls))  </span><br><span class="line">    .flatMap(<span class="keyword">new</span> Func1&lt;<span class="built_in">String</span>, Observable&lt;<span class="built_in">String</span>&gt;&gt;() &#123;  </span><br><span class="line">        @Override  </span><br><span class="line">        public Observable&lt;<span class="built_in">String</span>&gt; call(<span class="built_in">String</span> url) &#123;  </span><br><span class="line">            <span class="keyword">return</span> getTitle(url);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;)  </span><br><span class="line">    .subscribe(title -&gt; System.out.println(title));  </span><br></pre></td></tr></table></figure>
<p>使用lambda:</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">query(<span class="string">&quot;Hello, world!&quot;</span>)  </span><br><span class="line">    .flat<span class="constructor">Map(<span class="params">urls</span> -&gt; Observable.<span class="params">from</span>(<span class="params">urls</span>)</span>)  </span><br><span class="line">    .flat<span class="constructor">Map(<span class="params">url</span> -&gt; <span class="params">getTitle</span>(<span class="params">url</span>)</span>)  </span><br><span class="line">    .subscribe(title -&gt; <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(title));  </span><br></pre></td></tr></table></figure>
<p>是不是感觉很不可思议？我竟然能将多个独立的返回Observable对象的方法组合在一起！帅呆了！<br>不止这些，我还将两个API的调用组合到一个链式调用中了。我们可以将任意多个API调用链接起来。大家应该都应该知道同步所有的API调用，然后将所有API调用的回调结果组合成需要展示的数据是一件多么蛋疼的事情。这里我们成功的避免了callback hell（多层嵌套的回调，导致代码难以阅读维护）。现在所有的逻辑都包装成了这种简单的响应式调用。</p>
<h4 id="丰富的操作符"><a href="#丰富的操作符" class="headerlink" title="丰富的操作符"></a>丰富的操作符</h4><p>目前为止，我们已经接触了两个操作符，RxJava中还有更多的操作符，那么我们如何使用其他的操作符来改进我们的代码呢？<br>getTitle()返回null如果url不存在。我们不想输出”null”，那么我们可以从返回的title列表中过滤掉null值！</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">query(<span class="string">&quot;Hello, world!&quot;</span>)  </span><br><span class="line">    .<span class="function"><span class="title">flatMap</span>(urls -&gt;</span> Observable.from(urls))  </span><br><span class="line">    .<span class="function"><span class="title">flatMap</span>(url -&gt;</span> getTitle(url))  </span><br><span class="line">    .<span class="function"><span class="title">filter</span>(<span class="built_in">title</span> -&gt;</span> <span class="built_in">title</span> != null)  </span><br><span class="line">    .<span class="function"><span class="title">subscribe</span>(<span class="built_in">title</span> -&gt;</span> System.out.println(<span class="built_in">title</span>));  </span><br></pre></td></tr></table></figure>
<p>filter()输出和输入相同的元素，并且会过滤掉那些不满足检查条件的。</p>
<p>如果我们只想要最多5个结果：</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">query(<span class="string">&quot;Hello, world!&quot;</span>)  </span><br><span class="line">    .<span class="function"><span class="title">flatMap</span>(urls -&gt;</span> Observable.from(urls))  </span><br><span class="line">    .<span class="function"><span class="title">flatMap</span>(url -&gt;</span> getTitle(url))  </span><br><span class="line">    .<span class="function"><span class="title">filter</span>(<span class="built_in">title</span> -&gt;</span> <span class="built_in">title</span> != null)  </span><br><span class="line">    .take(<span class="number">5</span>)  </span><br><span class="line">    .<span class="function"><span class="title">subscribe</span>(<span class="built_in">title</span> -&gt;</span> System.out.println(<span class="built_in">title</span>));  </span><br></pre></td></tr></table></figure>
<p>take()输出最多指定数量的结果。</p>
<p>如果我们想在打印之前，把每个标题保存到磁盘：</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">query(<span class="string">&quot;Hello, world!&quot;</span>)  </span><br><span class="line">    .<span class="function"><span class="title">flatMap</span>(urls -&gt;</span> Observable.from(urls))  </span><br><span class="line">    .<span class="function"><span class="title">flatMap</span>(url -&gt;</span> getTitle(url))  </span><br><span class="line">    .<span class="function"><span class="title">filter</span>(<span class="built_in">title</span> -&gt;</span> <span class="built_in">title</span> != null)  </span><br><span class="line">    .take(<span class="number">5</span>)  </span><br><span class="line">    .<span class="function"><span class="title">doOnNext</span>(<span class="built_in">title</span> -&gt;</span> saveTitle(<span class="built_in">title</span>))  </span><br><span class="line">    .<span class="function"><span class="title">subscribe</span>(<span class="built_in">title</span> -&gt;</span> System.out.println(<span class="built_in">title</span>));  </span><br></pre></td></tr></table></figure>
<p>doOnNext()允许我们在每次输出一个元素之前做一些额外的事情，比如这里的保存标题。</p>
<p>看到这里操作数据流是多么简单了么。你可以添加任意多的操作，并且不会搞乱你的代码。</p>
<p>RxJava包含了大量的操作符。操作符的数量是有点吓人，但是很值得你去挨个看一下，这样你可以知道有哪些操作符可以使用。弄懂这些操作符可能会花一些时间，但是一旦弄懂了，你就完全掌握了RxJava的威力。</p>
<p>你甚至可以编写自定义的操作符！这篇blog不打算将自定义操作符，如果你想的话，清自行Google吧。</p>
<h4 id="感觉如何？"><a href="#感觉如何？" class="headerlink" title="感觉如何？"></a>感觉如何？</h4><p>好吧，你是一个怀疑主义者，并且还很难被说服，那为什么你要关心这些操作符呢？</p>
<p>因为操作符可以让你对数据流做任何操作。</p>
<p>将一系列的操作符链接起来就可以完成复杂的逻辑。代码被分解成一系列可以组合的片段。这就是响应式函数编程的魅力。用的越多，就会越多的改变你的编程思维。</p>
<p>另外，RxJava也使我们处理数据的方式变得更简单。在最后一个例子里，我们调用了两个API，对API返回的数据进行了处理，然后保存到磁盘。但是我们的Subscriber并不知道这些，它只是认为自己在接收一个Observable<String>对象。良好的封装性也带来了编码的便利！</p>
<p>在第三部分中，我将介绍RxJava的另外一些很酷的特性，比如错误处理和并发，这些特性并不会直接用来处理数据。</p>
<h3 id="三、响应式的好处"><a href="#三、响应式的好处" class="headerlink" title="三、响应式的好处"></a>三、响应式的好处</h3><p>在第一篇中，我介绍了RxJava的基础知识。第二篇中，我向你展示了操作符的强大。但是你可能仍然没被说服。这篇里面，我讲向你展示RxJava的其他的一些好处，相信这篇足够让你去使用Rxjava.</p>
<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>到目前为止，我们都没怎么介绍onComplete()和onError()函数。这两个函数用来通知订阅者，被观察的对象将停止发送数据以及为什么停止（成功的完成或者出错了）。</p>
<p>下面的代码展示了怎么使用这两个函数：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Observable</span>.<span class="title function_">just</span>(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line">    .<span class="title function_">map</span>(s -&gt; <span class="title function_">potentialException</span>(s))</span><br><span class="line">    .<span class="title function_">map</span>(s -&gt; <span class="title function_">anotherPotentialException</span>(s))</span><br><span class="line">    .<span class="title function_">subscribe</span>(<span class="keyword">new</span> <span class="title class_">Subscriber</span>&lt;<span class="title class_">String</span>&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">onNext</span>(<span class="params"><span class="built_in">String</span> s</span>) &#123; <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(s); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">onCompleted</span>(<span class="params"></span>) &#123; <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;Completed!&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">onError</span>(<span class="params">Throwable e</span>) &#123; <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;Ouch!&quot;</span>); &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>代码中的potentialException() 和 anotherPotentialException()有可能会抛出异常。每一个Observerable对象在终结的时候都会调用onCompleted()或者onError()方法，所以Demo中会打印”Completed!”或者”Ouch!”。</p>
<p>这种模式有以下几个优点：</p>
<p>1.只要有异常发生onError()一定会被调用</p>
<p>这极大的简化了错误处理。只需要在一个地方处理错误即可以。</p>
<p>2.操作符不需要处理异常</p>
<p>将异常处理交给订阅者来做，Observerable的操作符调用链中一旦有一个抛出了异常，就会直接执行onError()方法。</p>
<p>3.你能够知道什么时候订阅者已经接收了全部的数据。</p>
<p>知道什么时候任务结束能够帮助简化代码的流程。（虽然有可能Observable对象永远不会结束）</p>
<p>我觉得这种错误处理方式比传统的错误处理更简单。传统的错误处理中，通常是在每个回调中处理错误。这不仅导致了重复的代码，并且意味着每个回调都必须知道如何处理错误，你的回调代码将和调用者紧耦合在一起。</p>
<p>使用RxJava，Observable对象根本不需要知道如何处理错误！操作符也不需要处理错误状态-一旦发生错误，就会跳过当前和后续的操作符。所有的错误处理都交给订阅者来做。</p>
<h4 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h4><p>假设你编写的Android app需要从网络请求数据（感觉这是必备的了，还有单机么？）。网络请求需要花费较长的时间，因此你打算在另外一个线程中加载数据。那么问题来了！</p>
<p>编写多线程的Android应用程序是很难的，因为你必须确保代码在正确的线程中运行，否则的话可能会导致app崩溃。最常见的就是在非主线程更新UI。</p>
<p>使用RxJava，你可以使用subscribeOn()指定观察者代码运行的线程，使用observerOn()指定订阅者运行的线程：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myObservableServices.retrieve<span class="constructor">Image(<span class="params">url</span>)</span></span><br><span class="line">    .subscribe<span class="constructor">On(Schedulers.<span class="params">io</span>()</span>)</span><br><span class="line">    .observe<span class="constructor">On(AndroidSchedulers.<span class="params">mainThread</span>()</span>)</span><br><span class="line">    .subscribe(bitmap -&gt; myImageView.set<span class="constructor">ImageBitmap(<span class="params">bitmap</span>)</span>);</span><br></pre></td></tr></table></figure>
<p>是不是很简单？任何在我的Subscriber前面执行的代码都是在I/O线程中运行。最后，操作view的代码在主线程中运行.</p>
<p>最棒的是我可以把subscribeOn()和observerOn()添加到任何Observable对象上。这两个也是操作符！。我不需要关心Observable对象以及它上面有哪些操作符。仅仅运用这两个操作符就可以实现在不同的线程中调度。</p>
<p>如果使用AsyncTask或者其他类似的，我将不得不仔细设计我的代码，找出需要并发执行的部分。使用RxJava，我可以保持代码不变，仅仅在需要并发的时候调用这两个操作符就可以。</p>
<h4 id="订阅（Subscriptions）"><a href="#订阅（Subscriptions）" class="headerlink" title="订阅（Subscriptions）"></a>订阅（Subscriptions）</h4><p>当调用Observable.subscribe()，会返回一个Subscription对象。这个对象代表了被观察者和订阅者之间的联系。</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ubscription <span class="keyword">subscription</span> = Observable.just(&quot;Hello, World!&quot;)</span><br><span class="line">    .subscribe(s -&gt; <span class="keyword">System</span>.<span class="keyword">out</span>.println(s));</span><br></pre></td></tr></table></figure>
<p>你可以在后面使用这个Subscription对象来操作被观察者和订阅者之间的联系.</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">subscription</span>.unsubscribe();</span><br><span class="line"><span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;Unsubscribed=&quot; + <span class="keyword">subscription</span>.isUnsubscribed());</span><br><span class="line">// Outputs &quot;Unsubscribed=true&quot;</span><br></pre></td></tr></table></figure>
<p>RxJava的另外一个好处就是它处理unsubscribing的时候，会停止整个调用链。如果你使用了一串很复杂的操作符，调用unsubscribe将会在他当前执行的地方终止。不需要做任何额外的工作！</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>记住这个系列仅仅是对RxJava的一个入门介绍。RxJava中有更多的我没介绍的功能等你探索（比如backpressure）。当然我也不是所有的代码都使用响应式的方式–仅仅当代码复杂到我想将它分解成简单的逻辑的时候，我才使用响应式代码。</p>
<p>最初，我的计划是这篇文章作为这个系列的总结，但是我收到许多请求我介绍在Android中使用RxJava，所以你可以继续阅读第四篇了。我希望这个介绍能让你开始使用RxJava。如果你想学到更多，我建议你阅读RxJava的官方wiki。</p>
<h3 id="四、在Android中使用响应式编程"><a href="#四、在Android中使用响应式编程" class="headerlink" title="四、在Android中使用响应式编程"></a>四、在Android中使用响应式编程</h3><p>在第1，2，3篇中，我大概介绍了RxJava是怎么使用的。下面我会介绍如何在Android中使用RxJava.</p>
<h4 id="RxAndroid"><a href="#RxAndroid" class="headerlink" title="RxAndroid"></a>RxAndroid</h4><p>RxAndroid是RxJava的一个针对Android平台的扩展。它包含了一些能够简化Android开发的工具。</p>
<p>首先，AndroidSchedulers提供了针对Android的线程系统的调度器。需要在UI线程中运行某些代码？很简单，只需要使用<code>AndroidSchedulers.mainThread()</code>:</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">retrofitService.get<span class="constructor">Image(<span class="params">url</span>)</span></span><br><span class="line">    .subscribe<span class="constructor">On(Schedulers.<span class="params">io</span>()</span>)</span><br><span class="line">    .observe<span class="constructor">On(AndroidSchedulers.<span class="params">mainThread</span>()</span>)</span><br><span class="line">    .subscribe(bitmap -&gt; myImageView.set<span class="constructor">ImageBitmap(<span class="params">bitmap</span>)</span>);</span><br></pre></td></tr></table></figure>
<p>如果你已经创建了自己的Handler，你可以使用HandlerThreadScheduler1将一个调度器链接到你的handler上。</p>
<p>接着要介绍的就是AndroidObservable，它提供了跟多的功能来配合Android的生命周期。bindActivity()和bindFragment()方法默认使用AndroidSchedulers.mainThread()来执行观察者代码，这两个方法会在Activity或者Fragment结束的时候通知被观察者停止发出新的消息。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">AndroidObservable</span>.</span></span>bind<span class="constructor">Activity(<span class="params">this</span>, <span class="params">retrofitService</span>.<span class="params">getImage</span>(<span class="params">url</span>)</span>)</span><br><span class="line">    .subscribe<span class="constructor">On(Schedulers.<span class="params">io</span>()</span>)</span><br><span class="line">    .subscribe(bitmap -&gt; myImageView.set<span class="constructor">ImageBitmap(<span class="params">bitmap</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>我自己也很喜欢AndroidObservable.fromBroadcast()方法，它允许你创建一个类似BroadcastReceiver的Observable对象。下面的例子展示了如何在网络变化的时候被通知到：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IntentFilter filter = <span class="keyword">new</span> <span class="constructor">IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION)</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">AndroidObservable</span>.</span></span>from<span class="constructor">Broadcast(<span class="params">context</span>, <span class="params">filter</span>)</span></span><br><span class="line">    .subscribe(intent -&gt; handle<span class="constructor">ConnectivityChange(<span class="params">intent</span>)</span>);</span><br></pre></td></tr></table></figure>
<p>最后要介绍的是ViewObservable,使用它可以给View添加了一些绑定。如果你想在每次点击view的时候都收到一个事件，可以使用ViewObservable.clicks()，或者你想监听TextView的内容变化，可以使用ViewObservable.text()。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">ViewObservable</span>.</span></span>clicks(mCardNameEditText, <span class="literal">false</span>)</span><br><span class="line">    .subscribe(view -&gt; handle<span class="constructor">Click(<span class="params">view</span>)</span>);</span><br></pre></td></tr></table></figure>

<h4 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a>Retrofit</h4><p>大名鼎鼎的Retrofit库内置了对RxJava的支持。通常调用发可以通过使用一个Callback对象来获取异步的结果：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@GET</span>(<span class="string">&quot;/user/&#123;id&#125;/photo&quot;</span>)</span><br><span class="line">void <span class="built_in">getUserPhoto</span>(<span class="variable">@Path</span>(<span class="string">&quot;id&quot;</span>) int id, Callback&lt;Photo&gt; cb);</span><br></pre></td></tr></table></figure>

<p>使用RxJava，你可以直接返回一个Observable对象。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@GET</span>(<span class="string">&quot;/user/&#123;id&#125;/photo&quot;</span>)</span><br><span class="line">Observable&lt;Photo&gt; <span class="built_in">getUserPhoto</span>(<span class="variable">@Path</span>(<span class="string">&quot;id&quot;</span>) int id);</span><br></pre></td></tr></table></figure>

<p>现在你可以随意使用Observable对象了。你不仅可以获取数据，还可以进行变换。<br>Retrofit对Observable的支持使得它可以很简单的将多个REST请求结合起来。比如我们有一个请求是获取照片的，还有一个请求是获取元数据的，我们就可以将这两个请求并发的发出，并且等待两个结果都返回之后再做处理：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Observable</span>.</span></span>zip(</span><br><span class="line">    service.get<span class="constructor">UserPhoto(<span class="params">id</span>)</span>,</span><br><span class="line">    service.get<span class="constructor">PhotoMetadata(<span class="params">id</span>)</span>,</span><br><span class="line">    (photo, metadata) -&gt; create<span class="constructor">PhotoWithData(<span class="params">photo</span>, <span class="params">metadata</span>)</span>)</span><br><span class="line">    .subscribe(photoWithData -&gt; show<span class="constructor">Photo(<span class="params">photoWithData</span>)</span>);</span><br></pre></td></tr></table></figure>

<p>在第二篇里我展示过一个类似的例子（使用flatMap()）。这里我只是想展示以下使用RxJava+Retrofit可以多么简单地组合多个REST请求。</p>
<h4 id="遗留代码，运行极慢的代码"><a href="#遗留代码，运行极慢的代码" class="headerlink" title="遗留代码，运行极慢的代码"></a>遗留代码，运行极慢的代码</h4><p>Retrofit可以返回Observable对象，但是如果你使用的别的库并不支持这样怎么办？或者说一个内部的内码，你想把他们转换成Observable的？有什么简单的办法没？</p>
<p>绝大多数时候Observable.just() 和 Observable.from() 能够帮助你从遗留代码中创建 Observable 对象:</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title class_">Object</span> <span class="title function_">oldMethod</span>(<span class="params"></span>) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title class_">Observable</span>&lt;<span class="title class_">Object</span>&gt; <span class="title function_">newMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Observable</span>.<span class="title function_">just</span>(<span class="title function_">oldMethod</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子中如果oldMethod()足够快是没有什么问题的，但是如果很慢呢？调用oldMethod()将会阻塞住他所在的线程。<br>为了解决这个问题，可以参考我一直使用的方法–使用defer()来包装缓慢的代码：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title class_">Object</span> <span class="title function_">slowBlockingMethod</span>(<span class="params"></span>) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title class_">Observable</span>&lt;<span class="title class_">Object</span>&gt; <span class="title function_">newMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Observable</span>.<span class="title function_">defer</span>(() -&gt; <span class="title class_">Observable</span>.<span class="title function_">just</span>(<span class="title function_">slowBlockingMethod</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，newMethod()的调用不会阻塞了，除非你订阅返回的observable对象。</p>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>我把最难的不分留在了最后。如何处理Activity的生命周期？主要就是两个问题：<br>1.在configuration改变（比如转屏）之后继续之前的Subscription。</p>
<p>比如你使用Retrofit发出了一个REST请求，接着想在listview中展示结果。如果在网络请求的时候用户旋转了屏幕怎么办？你当然想继续刚才的请求，但是怎么搞？</p>
<p>2.Observable持有Context导致的内存泄露</p>
<p>这个问题是因为创建subscription的时候，以某种方式持有了context的引用，尤其是当你和view交互的时候，这太容易发生！如果Observable没有及时结束，内存占用就会越来越大。<br>不幸的是，没有银弹来解决这两个问题，但是这里有一些指导方案你可以参考。</p>
<p>第一个问题的解决方案就是使用RxJava内置的缓存机制，这样你就可以对同一个Observable对象执行unsubscribe/resubscribe，却不用重复运行得到Observable的代码。cache() (或者 replay())会继续执行网络请求（甚至你调用了unsubscribe也不会停止）。这就是说你可以在Activity重新创建的时候从cache()的返回值中创建一个新的Observable对象。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;Photo&gt; request = service.get<span class="constructor">UserPhoto(<span class="params">id</span>)</span>.cache<span class="literal">()</span>;</span><br><span class="line">Subscription sub = request.subscribe(photo -&gt; handle<span class="constructor">UserPhoto(<span class="params">photo</span>)</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...When the Activity is being recreated...</span></span><br><span class="line">sub.unsubscribe<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...Once the Activity is recreated...</span></span><br><span class="line">request.subscribe(photo -&gt; handle<span class="constructor">UserPhoto(<span class="params">photo</span>)</span>);</span><br></pre></td></tr></table></figure>

<p>注意，两次sub是使用的同一个缓存的请求。当然在哪里去存储请求的结果还是要你自己来做，和所有其他的生命周期相关的解决方案一延虎，必须在生命周期外的某个地方存储。（retained fragment或者单例等等）。</p>
<p>第二个问题的解决方案就是在生命周期的某个时刻取消订阅。一个很常见的模式就是使用CompositeSubscription来持有所有的Subscriptions，然后在onDestroy()或者onDestroyView()里取消所有的订阅。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> CompositeSubscription mCompositeSubscription</span><br><span class="line">    = <span class="keyword">new</span> CompositeSubscription();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSomething</span>()</span> &#123;</span><br><span class="line">    mCompositeSubscription.<span class="keyword">add</span>(</span><br><span class="line">        AndroidObservable.bindActivity(<span class="keyword">this</span>, Observable.just(<span class="string">&quot;Hello, World!&quot;</span>))</span><br><span class="line">        .subscribe(s -&gt; System.<span class="keyword">out</span>.println(s)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span>()</span> &#123;</span><br><span class="line">    super.onDestroy();</span><br><span class="line"></span><br><span class="line">    mCompositeSubscription.unsubscribe();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以在Activity/Fragment的基类里创建一个CompositeSubscription对象，在子类中使用它。</p>
<p>注意! 一旦你调用了 CompositeSubscription.unsubscribe()，这个CompositeSubscription对象就不可用了, 如果你还想使用CompositeSubscription，就必须在创建一个新的对象了。</p>
<p>两个问题的解决方案都需要添加额外的代码，如果谁有更好的方案，欢迎告诉我。</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>RxJava还是一个很新的项目，RxAndroid更是。RxAndroid目前还在活跃开发中，也没有多少好的例子。我打赌一年之后我的一些建议就会被看做过时了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://moqiang02.github.io/2016/04/23/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BARxJava/" data-id="cla0v66g1022ng0v1gi916ho0" data-title="深入浅出RxJava" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android%E5%BC%80%E6%BA%90/" rel="tag">Android开源</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/04/23/RxJava%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E5%92%8Clift%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          RxJava基本流程和lift源码分析
        
      </div>
    </a>
  
  
    <a href="/2016/04/23/%E7%BB%99-Android-%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-RxJava-%E8%AF%A6%E8%A7%A3/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">给 Android 开发者的 RxJava 详解</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/android/">android</a><span class="category-list-count">255</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/apache/">apache</a><span class="category-list-count">27</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/flutter/">flutter</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/github%E5%8D%9A%E5%AE%A2/">github博客</a><span class="category-list-count">19</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/go/">go</a><span class="category-list-count">26</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/html-css/">html+css</a><span class="category-list-count">27</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iis/">iis</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">84</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/">javascript</a><span class="category-list-count">124</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/kotlin/">kotlin</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">68</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mac/">mac</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/memcached/">memcached</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mongodb/">mongodb</a><span class="category-list-count">19</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a><span class="category-list-count">74</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/">nginx</a><span class="category-list-count">42</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/nodejs/">nodejs</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/php/">php</a><span class="category-list-count">185</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a><span class="category-list-count">44</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%B6%E5%AE%83/">其它</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a><span class="category-list-count">52</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/">开源项目</a><span class="category-list-count">73</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/">生活随笔</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93/">量化交易</a><span class="category-list-count">3</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/AndroidStudio/" style="font-size: 13.16px;">AndroidStudio</a> <a href="/tags/AndroidUI/" style="font-size: 20px;">AndroidUI</a> <a href="/tags/Android%E4%BA%8B%E4%BB%B6%E6%8B%A6%E6%88%AA/" style="font-size: 11.05px;">Android事件拦截</a> <a href="/tags/Android%E5%BC%80%E6%BA%90/" style="font-size: 16.84px;">Android开源</a> <a href="/tags/CI/" style="font-size: 15.26px;">CI</a> <a href="/tags/CURL/" style="font-size: 12.63px;">CURL</a> <a href="/tags/DEDE/" style="font-size: 17.37px;">DEDE</a> <a href="/tags/Docker/" style="font-size: 14.21px;">Docker</a> <a href="/tags/Flask/" style="font-size: 10.53px;">Flask</a> <a href="/tags/JavaSE/" style="font-size: 18.42px;">JavaSE</a> <a href="/tags/Laravel/" style="font-size: 16.84px;">Laravel</a> <a href="/tags/Maven/" style="font-size: 11.58px;">Maven</a> <a href="/tags/MybatisPlus/" style="font-size: 11.05px;">MybatisPlus</a> <a href="/tags/Puppeteer/" style="font-size: 14.74px;">Puppeteer</a> <a href="/tags/SVN/" style="font-size: 10px;">SVN</a> <a href="/tags/Selenium/" style="font-size: 11.58px;">Selenium</a> <a href="/tags/SpringBoot/" style="font-size: 19.47px;">SpringBoot</a> <a href="/tags/Thinkphp/" style="font-size: 10px;">Thinkphp</a> <a href="/tags/UEditor/" style="font-size: 11.58px;">UEditor</a> <a href="/tags/VMware/" style="font-size: 12.11px;">VMware</a> <a href="/tags/Vue/" style="font-size: 18.95px;">Vue</a> <a href="/tags/WebSocket/" style="font-size: 12.63px;">WebSocket</a> <a href="/tags/ecshop/" style="font-size: 14.21px;">ecshop</a> <a href="/tags/scrapy/" style="font-size: 13.68px;">scrapy</a> <a href="/tags/smarty/" style="font-size: 12.11px;">smarty</a> <a href="/tags/socket/" style="font-size: 14.21px;">socket</a> <a href="/tags/sphinx/" style="font-size: 11.58px;">sphinx</a> <a href="/tags/vagrant/" style="font-size: 12.11px;">vagrant</a> <a href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" style="font-size: 11.05px;">微服务</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/" style="font-size: 15.26px;">数据传输</a> <a href="/tags/%E6%AD%A3%E5%88%99/" style="font-size: 11.58px;">正则</a> <a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size: 15.79px;">消息队列</a> <a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size: 17.89px;">爬虫</a> <a href="/tags/%E9%9B%86%E7%BE%A4/" style="font-size: 16.32px;">集群</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/08/27/%E5%88%A9%E7%94%A8Jenkins%E4%B8%8EDocker%E5%AE%9E%E7%8E%B0Spring-Boot%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E4%B9%8B%E9%81%93/">利用Jenkins与Docker实现Spring Boot项目的自动化部署之道</a>
          </li>
        
          <li>
            <a href="/2025/08/27/Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E4%B8%AD%E5%90%8E%E7%AB%AF%E8%8A%82%E7%82%B9%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5/">Nginx负载均衡中后端节点服务器健康检查</a>
          </li>
        
          <li>
            <a href="/2025/06/19/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82Vue%E4%B8%AD%E7%9A%84Mixin%E6%B7%B7%E5%85%A5/">彻底搞懂Vue中的Mixin混入</a>
          </li>
        
          <li>
            <a href="/2025/03/14/%E5%A6%82%E4%BD%95%E5%8F%91%E5%B8%83jar%E5%8C%85%E5%88%B0maven%E4%B8%AD%E5%A4%AE%E4%BB%93%E5%BA%93/">如何发布jar包到maven中央仓库</a>
          </li>
        
          <li>
            <a href="/2025/03/14/%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8-Redis-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97%EF%BC%9F/">怎么使用Redis实现一个延时队列？</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 moqiang<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>

<!-- rex -->

<script src="/js/toc.js"></script>


  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>