<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Java8中使用Lambda表达式简化代码(小豆丁技术栈) | 自强不息</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="一、Lambda 表达式简介1、什么是 Lambda 表达式       Lambda 表达式是在 JDK 8 中引入的一个新特性，可用于取代大部分的匿名内部类。使用 Lambda 表达式可以完成用少量的代码实现复杂的功能，极大的简化代码代码量和代码结构。同时，JDK 中也增加了大量的内置函数式接口供我们使用，使得在使用 Lambda 表达式时更加简单、高效。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java8中使用Lambda表达式简化代码(小豆丁技术栈)">
<meta property="og:url" content="http://moqiang02.github.io/2022/11/02/Java8%E4%B8%AD%E4%BD%BF%E7%94%A8Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AE%80%E5%8C%96%E4%BB%A3%E7%A0%81/index.html">
<meta property="og:site_name" content="自强不息">
<meta property="og:description" content="一、Lambda 表达式简介1、什么是 Lambda 表达式       Lambda 表达式是在 JDK 8 中引入的一个新特性，可用于取代大部分的匿名内部类。使用 Lambda 表达式可以完成用少量的代码实现复杂的功能，极大的简化代码代码量和代码结构。同时，JDK 中也增加了大量的内置函数式接口供我们使用，使得在使用 Lambda 表达式时更加简单、高效。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-11-02T04:20:49.000Z">
<meta property="article:modified_time" content="2022-11-02T05:56:37.728Z">
<meta property="article:author" content="moqiang">
<meta property="article:tag" content="JavaSE">
<meta name="twitter:card" content="summary">
  
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">自强不息</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://moqiang02.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Java8中使用Lambda表达式简化代码" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/02/Java8%E4%B8%AD%E4%BD%BF%E7%94%A8Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AE%80%E5%8C%96%E4%BB%A3%E7%A0%81/" class="article-date">
  <time class="dt-published" datetime="2022-11-02T04:20:49.000Z" itemprop="datePublished">2022-11-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Java8中使用Lambda表达式简化代码(小豆丁技术栈)
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      

          <!-- rex -->
          
            <!-- 文章目录开始 -->
            
              <div id="toc" class="toc-article">
              <strong class="toc-title" style="cursor:pointer">目录</strong>
              <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">一、Lambda 表达式简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text">1、什么是 Lambda 表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.2.</span> <span class="toc-text">2、为什么需要 Lambda 表达式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%AE%9A%E4%B9%89"><span class="toc-number">2.</span> <span class="toc-text">二、函数式接口和定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.1.</span> <span class="toc-text">1、什么是函数式接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">2、函数式接口格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E5%92%8C-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.3.</span> <span class="toc-text">3、函数式接口和 Lambda 表达式的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%BD%93%E5%89%8D-JDK-8-%E4%B8%AD%E5%AD%98%E5%9C%A8%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E7%B1%BB"><span class="toc-number">2.4.</span> <span class="toc-text">4、当前 JDK 8 中存在的函数式接口类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81JDK-%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E7%B1%BB"><span class="toc-number">2.5.</span> <span class="toc-text">5、JDK 中常见的函数式接口类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">三、Lambda 表达式基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">3.1.</span> <span class="toc-text">1、Lambda 表达式的组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.2.</span> <span class="toc-text">2、Lambda 表达式的格式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">4.</span> <span class="toc-text">四、Lambda 表达式中变量作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E9%97%AE%E9%A2%98"><span class="toc-number">5.</span> <span class="toc-text">五、Lambda 表达式方法重载问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-number">6.</span> <span class="toc-text">六、Lambda 表达式方法引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%88%9B%E5%BB%BA%E7%A4%BA%E4%BE%8B%E7%9A%84%E5%AE%9E%E4%BD%93%E7%B1%BB"><span class="toc-number">6.1.</span> <span class="toc-text">1、创建示例的实体类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.2.</span> <span class="toc-text">2、静态方法引用示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.3.</span> <span class="toc-text">3、实例方法引用示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.4.</span> <span class="toc-text">4、构造方法引用示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E7%89%B9%E5%AE%9A%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BB%BB%E6%84%8F%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.5.</span> <span class="toc-text">5、特定类型的任意对象实例方法引用示例</span></a></li></ol></li></ol>
              </div>
            
            <!-- 文章目录结束 -->	  
          

        <h2 id="一、Lambda-表达式简介"><a href="#一、Lambda-表达式简介" class="headerlink" title="一、Lambda 表达式简介"></a>一、Lambda 表达式简介</h2><h3 id="1、什么是-Lambda-表达式"><a href="#1、什么是-Lambda-表达式" class="headerlink" title="1、什么是 Lambda 表达式"></a>1、什么是 Lambda 表达式</h3><p>       <code>Lambda</code> 表达式是在 JDK 8 中引入的一个新特性，可用于取代大部分的匿名内部类。使用 <code>Lambda</code> 表达式可以完成用少量的代码实现复杂的功能，极大的简化代码代码量和代码结构。同时，JDK 中也增加了大量的内置函数式接口供我们使用，使得在使用 Lambda 表达式时更加简单、高效。<span id="more"></span></p>
<h3 id="2、为什么需要-Lambda-表达式"><a href="#2、为什么需要-Lambda-表达式" class="headerlink" title="2、为什么需要 Lambda 表达式"></a>2、为什么需要 Lambda 表达式</h3><p>       谈起为什么需要 <code>Lambda</code> 表达式，那得从函数式编程开始说起。<code>函数式编程</code>可以简单说是一种<code>编程规范</code>，也就是如何编写程序的方法论。它属于<code>结构化编程</code>的一种，主要思想是把运算过程尽量写成一系列嵌套的函数调用。函数式编程有很多优点，其中包括：</p>
<ul>
<li>  易于并发编程；</li>
<li>  代码的热升级；</li>
<li>  更方便的代码管理；</li>
<li>  代码简洁，开发快速；</li>
<li>  接近自然语言，易于理解；</li>
</ul>
<p>函数式编程在 <code>C#</code>、<code>Python</code>、<code>JavaScript</code>中都得到充分体现，在 Java 8 版本中也得到了支持。最明显的就是对 <code>Lambda</code> 表达式的支持。很多种迹象表明未来编程语言将是逐渐融合各自的特性，而不是单纯的声明式语言函数编程语言。将来声明式编程语言借鉴函数编程思想，函数编程语言融合声明式编程特性，这几乎是一种必然趋势。</p>
<p><strong>在 Java 中主要引入 Lambda 表达式的作用是对现有编码语义的优化，减少语法冗余。轻量级的将代码封装为数据，使代码简洁，易于理解。</strong></p>
<h2 id="二、函数式接口和定义"><a href="#二、函数式接口和定义" class="headerlink" title="二、函数式接口和定义"></a>二、函数式接口和定义</h2><h3 id="1、什么是函数式接口"><a href="#1、什么是函数式接口" class="headerlink" title="1、什么是函数式接口"></a>1、什么是函数式接口</h3><p>       函数式接口（Functional Interface）是<code>一个有且仅有一个抽象方法，但是可以有多个非抽象方法</code>的接口。Java 中函数式接口被隐式转换为 Lambda 表达式，只有保证接口类中有且只有一个抽象方法，Java 中的 Lambda 表达式才能对该方法进行推导。</p>
<h3 id="2、函数式接口格式"><a href="#2、函数式接口格式" class="headerlink" title="2、函数式接口格式"></a>2、函数式接口格式</h3><p>在 Java 函数式接口类中，需要满足接口类中只能有一个抽象方法。总结如下：</p>
<ul>
<li>  接口有且仅有一个抽象方法；</li>
<li>  允许定义静态方法；</li>
<li>  允许定义默认方法；</li>
<li>  允许 java.lang.Object 中的 public 方法；</li>
</ul>
<p>在创建函数式接口时，可以在接口类上面加上<code>@FunctionalInterface</code>注解，这时编译器就可以<code>对接口结构</code>进行<code>强制检查</code>是否符合函数式接口规则，如果<code>不符合规则</code>就显示错误。当然，这个注解只是用于检查，即使不加上该注解，<code>只要符合函数式接口规则</code>一样也是函数式接口。</p>
<p>下面创建个演示的函数式接口，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @FunctionalInterface 注解说明：</span></span><br><span class="line"><span class="comment">// 使用该注解来定义接口，编译器会强制检查接口是否符合函数式接口规则（有且仅有一个抽象方法），如果不符合则会报错。</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyInterface</span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抽象方法（Jdk 8 以后接口类中方法可以省去 public abstract）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> [返回值类型] [方法名称](参数列表);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 其它方法（Jdk 8 以后允许接口类中添加&quot;默认方法&quot;与&quot;静态方法&quot; ）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ...(略)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照上面函数式接口，定义一个示例的函数式接口类，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyCollection</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(List list)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、函数式接口和-Lambda-表达式的关系"><a href="#3、函数式接口和-Lambda-表达式的关系" class="headerlink" title="3、函数式接口和 Lambda 表达式的关系"></a>3、函数式接口和 Lambda 表达式的关系</h3><p>函数式接口和 Lambda 表达式的关系可以总结为：</p>
<ul>
<li>  函数式接口只包含一个操作方法；</li>
<li>  Lambda 表达式只能操作一个方法；</li>
<li>  Java 中的 Lambda 表达式核心就是一个函数式编程接口的实现。</li>
</ul>
<h3 id="4、当前-JDK-8-中存在的函数式接口类"><a href="#4、当前-JDK-8-中存在的函数式接口类" class="headerlink" title="4、当前 JDK 8 中存在的函数式接口类"></a>4、当前 JDK 8 中存在的函数式接口类</h3><p>在 JDK 1.8 之前，已经存在部分函数式接口，如下:</p>
<ul>
<li>  java.lang.Runnable</li>
<li>  java.util.concurrent.Callable</li>
<li>  java.security.PrivilegedAction</li>
<li>  java.util.Comparator</li>
<li>  java.io.FileFilter</li>
<li>  java.nio.file.PathMatcher</li>
<li>  java.lang.reflect.InvocationHandler</li>
<li>  java.beans.PropertyChangeListener</li>
<li>  java.awt.event.ActionListener</li>
<li>  javax.swing.event.ChangeListener</li>
</ul>
<p>在 JDK 8 中新增了函数接口 java.util.function 包，里面包含了很多用来支持 Java 的函数式编程的接口类，如下：</p>
<table>
<thead>
<tr>
<th>类名称</th>
<th>描述信息</th>
</tr>
</thead>
<tbody><tr>
<td>BiConsumer&lt;T,U&gt;</td>
<td>代表了一个接受两个输入参数的操作，并且不返回任何结果。</td>
</tr>
<tr>
<td>BiFunction&lt;T,U,R&gt;</td>
<td>代表了一个接受两个输入参数的方法，并且返回一个结果。</td>
</tr>
<tr>
<td>BinaryOperator<T></td>
<td>代表了一个作用于于两个同类型操作符的操作，并且返回了操作符同类型的结果。</td>
</tr>
<tr>
<td>BiPredicate&lt;T,U&gt;</td>
<td>代表了一个两个参数的 boolean 值方法。</td>
</tr>
<tr>
<td>BooleanSupplier</td>
<td>代表了 boolean 值结果的提供方。</td>
</tr>
<tr>
<td>Consumer<T></td>
<td>代表了接受一个输入参数并且无返回的操作。</td>
</tr>
<tr>
<td>DoubleBinaryOperator</td>
<td>代表了作用于两个 double 值操作符的操作，并且返回了一个 double 值的结果。</td>
</tr>
<tr>
<td>DoubleConsumer</td>
<td>代表一个接受 double 值参数的操作，并且不返回结果。</td>
</tr>
<tr>
<td>DoubleFunction<R></td>
<td>代表接受一个 double 值参数的方法，并且返回结果。</td>
</tr>
<tr>
<td>DoublePredicate</td>
<td>代表一个拥有 double 值参数的 boolean 值方法。</td>
</tr>
<tr>
<td>DoubleSupplier</td>
<td>代表一个 double 值结构的提供方。</td>
</tr>
<tr>
<td>DoubleToIntFunction</td>
<td>接受一个 double 类型输入，返回一个 int 类型结果。</td>
</tr>
<tr>
<td>DoubleToLongFunction</td>
<td>接受一个 double 类型输入，返回一个 long 类型结果。</td>
</tr>
<tr>
<td>DoubleUnaryOperator</td>
<td>接受一个参数同为类型 double,返回值类型也为 double。</td>
</tr>
<tr>
<td>Function&lt;T,R&gt;</td>
<td>接受一个输入参数，返回一个结果。</td>
</tr>
<tr>
<td>IntBinaryOperator</td>
<td>接受两个参数同为类型 int,返回值类型也为 int。</td>
</tr>
<tr>
<td>IntConsumer</td>
<td>接受一个 int 类型的输入参数，无返回值。</td>
</tr>
<tr>
<td>IntFunction<R></td>
<td>接受一个 int 类型输入参数，返回一个结果。</td>
</tr>
<tr>
<td>IntPredicate</td>
<td>接受一个 int 输入参数，返回一个布尔值的结果。</td>
</tr>
<tr>
<td>IntSupplier</td>
<td>无参数，返回一个 int 类型结果。</td>
</tr>
<tr>
<td>IntToDoubleFunction</td>
<td>接受一个 int 类型输入，返回一个double类型结果。</td>
</tr>
<tr>
<td>IntToLongFunction</td>
<td>接受一个 int 类型输入，返回一个 long 类型结果。</td>
</tr>
<tr>
<td>IntUnaryOperator</td>
<td>接受一个参数同为类型 int,返回值类型也为 int。</td>
</tr>
<tr>
<td>LongBinaryOperator</td>
<td>接受两个参数同为类型 long,返回值类型也为 long。</td>
</tr>
<tr>
<td>LongConsumer</td>
<td>接受一个 long 类型的输入参数，无返回值。</td>
</tr>
<tr>
<td>LongFunction<R></td>
<td>接受一个 long 类型输入参数，返回一个结果。</td>
</tr>
<tr>
<td>LongPredicate</td>
<td>R接受一个 long 输入参数，返回一个布尔值类型结果。</td>
</tr>
<tr>
<td>LongSupplier</td>
<td>无参数，返回一个结果 long 类型的值。</td>
</tr>
<tr>
<td>LongToDoubleFunction</td>
<td>接受一个 long 类型输入，返回一个 double 类型结果。</td>
</tr>
<tr>
<td>LongToIntFunction</td>
<td>接受一个 long 类型输入，返回一个 int 类型结果。</td>
</tr>
<tr>
<td>LongUnaryOperator</td>
<td>接受一个参数同为类型 long,返回值类型也为 long。</td>
</tr>
<tr>
<td>ObjDoubleConsumer<T></td>
<td>接受一个 object 类型和一个 double 类型的输入参数，无返回值。</td>
</tr>
<tr>
<td>ObjIntConsumer<T></td>
<td>接受一个 object 类型和一个 int 类型的输入参数，无返回值。</td>
</tr>
<tr>
<td>ObjLongConsumer<T></td>
<td>接受一个 object 类型和一个 long 类型的输入参数，无返回值。</td>
</tr>
<tr>
<td>Predicate<T></td>
<td>接受一个输入参数，返回一个布尔值结果。</td>
</tr>
<tr>
<td>Supplier<T></td>
<td>无参数，返回一个结果。</td>
</tr>
<tr>
<td>ToDoubleBiFunction&lt;T,U&gt;</td>
<td>接受两个输入参数，返回一个 double 类型结果</td>
</tr>
<tr>
<td>ToDoubleFunction<T></td>
<td>接受一个输入参数，返回一个 double 类型结果。</td>
</tr>
<tr>
<td>ToIntBiFunction&lt;T,U&gt;</td>
<td>接受两个输入参数，返回一个 int 类型结果。</td>
</tr>
<tr>
<td>ToIntFunction<T></td>
<td>接受一个输入参数，返回一个 int 类型结果。</td>
</tr>
<tr>
<td>ToLongBiFunction&lt;T,U&gt;</td>
<td>接受两个输入参数，返回一个 long 类型结果。</td>
</tr>
<tr>
<td>ToLongFunction<T></td>
<td>接受一个输入参数，返回一个 long 类型结果。</td>
</tr>
<tr>
<td>UnaryOperator<T></td>
<td>接受一个参数为类型 T,返回值类型也为 T。</td>
</tr>
</tbody></table>
<h3 id="5、JDK-中常见的函数式接口类"><a href="#5、JDK-中常见的函数式接口类" class="headerlink" title="5、JDK 中常见的函数式接口类"></a>5、JDK 中常见的函数式接口类</h3><p>上面 java.util.function 包提供了众多的函数式接口，其中常用的有：</p>
<ul>
<li>  java.util.function.Predicate<T>：接收参数对象 T，返回一个 boolean 类型结果。</li>
<li>  java.util.function.Comsumer<T>：接收参数对象 T，不返回结果。</li>
<li>  java.util.function.Function&lt;T,R&gt;：接收参数对象 T，返回结果对象 R。</li>
<li>  java.util.function.Supplier<T>：不接收参数，提供 T 对象的创建工厂。</li>
<li>  java.util.function.UnaryOperator<T>：接收参数对象 T，返回结果对象 T。</li>
<li>  java.util.function.BinaryOperator<T>：接收两个 T 对象，返回一个 T 对象结果。</li>
</ul>
<blockquote>
<p>注：为了使易懂，下面示例中 Lambda 表达式没有使用的最简易写法，而是使用比较繁琐的写法。</p>
</blockquote>
<p><strong>(1)、java.util.function.Predicate<T></strong></p>
<ul>
<li>  <strong>接口类作用：</strong> 接收参数对象T，返回一个 boolean 类型结果。</li>
<li>  <strong>接口类源码：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Predicate</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/** abstract 方法，接收一个参数, 判断这个参数是否匹配某种规则, 然后返回布尔值结果 */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(T t)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** default 方法，接收另外一个 Predicate&lt;T&gt; 类型参数进行&quot;逻辑与&quot;操作，返回一个新的 Predicate */</span></span><br><span class="line">    <span class="keyword">default</span> Predicate&lt;T&gt; <span class="title function_">and</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; other)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** default 方法，接收另外一个 Predicate&lt;T&gt; 类型参数进行&quot;逻辑或&quot;操作，返回一个新的 Predicate */</span></span><br><span class="line">    <span class="keyword">default</span> Predicate&lt;T&gt; <span class="title function_">negate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; !test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** default 方法，返回当前 Predicate 取反操作之后的 Predicate */</span></span><br><span class="line">    <span class="keyword">default</span> Predicate&lt;T&gt; <span class="title function_">or</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; other)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) || other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; Predicate&lt;T&gt; <span class="title function_">isEqual</span><span class="params">(Object targetRef)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">null</span> == targetRef)</span><br><span class="line">                ? Objects::isNull</span><br><span class="line">                : object -&gt; targetRef.equals(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PredicateExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 这里创建一个 Prodicate，设置验证秘钥的一个逻辑，然后返回并输出验证结果 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 Predicate 及 Lambda 表达式与待实现的逻辑</span></span><br><span class="line">        Predicate&lt;String&gt; validation = (String secret) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;123456&quot;</span>.equals(secret);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 调用 Predicate 提供的 test 方法并输出结果</span></span><br><span class="line">        System.out.println(validation.test(<span class="string">&quot;123&quot;</span>));</span><br><span class="line">        System.out.println(validation.test(<span class="string">&quot;123456&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>日常开发中，需要对某个值进行判断操作，并且返回判断结果，这时可以考虑使用 Predicate 接口，以及它的 Lambda 表达式的实现，能方便的实现我们业务上的一些功能。</p>
<p><strong>(2)、java.util.function.Comsumer<T></strong></p>
<ul>
<li>  <strong>接口类作用：</strong> 接收参数对象 T，不返回结果。</li>
<li>  <strong>接口类源码：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Consumer</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** abstract 方法，接收一个参数，执行消费逻辑 */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t)</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/** default 方法，将两个 Consumer 连接到一起，再进行消费 */</span></span><br><span class="line">    <span class="keyword">default</span> Consumer&lt;T&gt; <span class="title function_">andThen</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; after)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 这里创建一个 Consumer，模拟发送消息并打印内容 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 Consumer 及 Lambda 表达式与待实现的逻辑</span></span><br><span class="line">        Consumer&lt;String&gt; consumer = (String message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;发送消息内容：&quot;</span> + message);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 调用 Consumer 提供的 accept 方法</span></span><br><span class="line">        consumer.accept(<span class="string">&quot;测试消息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>日常开发中，需要对某个类型进行公共处理，并且不需要任何返回值，这时可以考虑使用 Consumer 接口及它的 Lambda 表达式的实现，能方便的实现我们业务上的一些功能。</p>
<p><strong>(3)、java.util.function.Function&lt;T,R&gt;</strong></p>
<ul>
<li>  <strong>接口类作用：</strong> 接收参数对象 T，返回结果对象 R。</li>
<li>  <strong>接口类源码：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Function</span>&lt;T, R&gt; &#123;</span><br><span class="line">    <span class="comment">/**abstract 方法，接收一个参数进行处理，然后返回处理结果 R */</span></span><br><span class="line">    R <span class="title function_">apply</span><span class="params">(T t)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** default 方法，先执行参数(Function)的，再执行调用者(Function) */</span></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; Function&lt;V, R&gt; <span class="title function_">compose</span><span class="params">(Function&lt;? <span class="built_in">super</span> V, ? extends T&gt; before)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(before);</span><br><span class="line">        <span class="keyword">return</span> (V v) -&gt; apply(before.apply(v));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** default 方法，先执行调用者，再执行参数，和compose相反 */</span></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; Function&lt;T, V&gt; <span class="title function_">andThen</span><span class="params">(Function&lt;? <span class="built_in">super</span> R, ? extends V&gt; after)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; after.apply(apply(t));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 返回当前正在执行的方法 */</span></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; Function&lt;T, T&gt; <span class="title function_">identity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t -&gt; t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 这里创建一个 Function，对传入的参数进行验证，如果包含 a 字符就返回1，否则返回0 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FunctionExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 Function 及 Lambda 表达式与待实现的逻辑</span></span><br><span class="line">        Function&lt;String, Integer&gt; function = (String str) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> str.contains(<span class="string">&quot;a&quot;</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 调用 Function 提供的 apply 方法</span></span><br><span class="line">        System.out.println(function.apply(<span class="string">&quot;abcd&quot;</span>));</span><br><span class="line">        System.out.println(function.apply(<span class="string">&quot;efgh&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>日常开发中，需要对某个类型数据进行操作，经过一系列逻辑后转换为一个新的类型进行返回，这时可以考虑使用 Function 接口及它的 Lambda 表达式的实现，能方便的实现我们业务上的一些功能。</p>
<p><strong>(4)、java.util.function.Supplier<T></strong></p>
<ul>
<li>  <strong>接口类作用：</strong> 不接收参数，提供 T 对象的创建工厂。</li>
<li>  <strong>接口类源码：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Supplier</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/** abstract 方法，设置业务逻辑，获取逻辑中创建的对象 */</span></span><br><span class="line">    T <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 这里创建一个 Supplier，用于生成随机ID，通过 get 方法获取生成的随机ID值 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SupplierExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 Supplier 及 Lambda 表达式与待实现的逻辑</span></span><br><span class="line">        Supplier&lt;String&gt; supplier = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> UUID.randomUUID().toString();</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 调用 Supplier 提供的 get 方法</span></span><br><span class="line">        System.out.println(supplier.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>日常开发中，需要创建一个统一的工厂用于生成特定的产物完成特定的目标，这时就可以考虑使用 Supplier 接口及它的 Lambda 表达式的实现，能方便的实现我们业务上的一些功能。</p>
<p><strong>(5)、java.util.function.UnaryOperator<T></strong></p>
<ul>
<li>  <strong>接口类作用：</strong> 接收参数对象 T，返回结果对象 T。</li>
<li>  <strong>接口类源码：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以看到 UnaryOperator 继承了 Function 接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UnaryOperator</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Function</span>&lt;T, T&gt; &#123;</span><br><span class="line">    <span class="comment">/** static 方法，接收一个参数，然后对其处理后再返回 */</span></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; UnaryOperator&lt;T&gt; <span class="title function_">identity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t -&gt; t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 这里创建一个 UnaryOperator，接收一个字符串进行加工处理后返回新字符串 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnaryOperatorExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 UnaryOperator 及 Lambda 表达式与待实现的逻辑</span></span><br><span class="line">        UnaryOperator&lt;String&gt; unaryOperator = (String str) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;[&quot;</span> + str + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 调用 UnaryOperator 继承的 Function 提供的 apply 方法</span></span><br><span class="line">        System.out.println(unaryOperator.apply(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>日常开发中，我们经常要对一个已有的对象进行操作修改，然后返回修改后的对象，这时就可以考虑使用 UnaryOperator 接口及它的 Lambda 表达式的实现，能方便的实现我们业务上的一些功能。</p>
<p><strong>(6)、java.util.function.BinaryOperator<T></strong></p>
<ul>
<li>  <strong>接口类作用：</strong> 接收两个 T 对象，返回一个 T 对象结果。</li>
<li>  <strong>接口类源码：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BinaryOperator</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">BiFunction</span>&lt;T,T,T&gt; &#123;</span><br><span class="line">    <span class="comment">/** abstract 方法，通过比较器Comparator来比较两个元素中较小的一个作为返回值返回 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; BinaryOperator&lt;T&gt; <span class="title function_">minBy</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> T&gt; comparator)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(comparator);</span><br><span class="line">        <span class="keyword">return</span> (a, b) -&gt; comparator.compare(a, b) &lt;= <span class="number">0</span> ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 通过比较器Comparator来比较两个元素中较大的一个作为返回值返回 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; BinaryOperator&lt;T&gt; <span class="title function_">maxBy</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> T&gt; comparator)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(comparator);</span><br><span class="line">        <span class="keyword">return</span> (a, b) -&gt; comparator.compare(a, b) &gt;= <span class="number">0</span> ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 这里创建一个 BinaryOperator，比较传入的两个参数哪个值最大，返回最大值 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryOperatorExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 BinaryOperator 及 Lambda 表达式与待实现的逻辑</span></span><br><span class="line">        BinaryOperator&lt;Integer&gt; binaryOperator = (Integer t1, Integer t2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> t1 &gt; t2 ? t1 : t2;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 调用 BinaryOperator 继承的 BiFunction 提供的 apply 方法</span></span><br><span class="line">        System.out.println(binaryOperator.apply(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在使用这几种基本函数接口时传入参数 T 不能是基本类型，如 BinaryOperator 中 T 不能设置为 int，只能使用 Integer 包装类，这也限制了 Lambda 表达式中设置参数时候，使用包装类替换基本类型。</p>
</blockquote>
<p>日常开发中，我们有时候会对两个对象进行操作，执行一些操作逻辑后返回结果，这时就可以考虑使用 BinaryOperator 接口及它的 Lambda 表达式的实现，能方便的实现我们业务上的一些功能。</p>
<h2 id="三、Lambda-表达式基本语法"><a href="#三、Lambda-表达式基本语法" class="headerlink" title="三、Lambda 表达式基本语法"></a>三、Lambda 表达式基本语法</h2><h3 id="1、Lambda-表达式的组成"><a href="#1、Lambda-表达式的组成" class="headerlink" title="1、Lambda 表达式的组成"></a>1、Lambda 表达式的组成</h3><p>Lambda 表达式的组成可以拆分为：</p>
<ul>
<li><p>  <strong>声明：</strong> 与 Lambda 表达式绑定的接口类型。</p>
</li>
<li><p>  <strong>参数：</strong> 参数包含在一对 <code>()</code> 中，和绑定的接口中的抽象方法中的参数个数及顺序一致。</p>
</li>
<li><p>  <strong>操作符：</strong> <code>-&gt;</code></p>
</li>
<li><p><strong>执行代码块：</strong> 执行代码块包含在一对 <code>&#123;&#125;</code> 中，出现在操作符的右侧。</p>
<p>  <code>[接口声明] = (参数) -&gt; &#123;执行代码块&#125;</code></p>
</li>
</ul>
<h3 id="2、Lambda-表达式的格式"><a href="#2、Lambda-表达式的格式" class="headerlink" title="2、Lambda 表达式的格式"></a>2、Lambda 表达式的格式</h3><p>Lambda 表达式可以分为下面几种格式：</p>
<ul>
<li>  无参数，无返回值；</li>
<li>  有一个参数，无返回值；</li>
<li>  左侧只有一个参数，小括号可以省略不写；</li>
<li>  有两个以上参数，有返回值，并且Lambda 体中有多条语句；</li>
<li>  若右侧Lambda体中，只有一条语句，return 和大括号都可以省略不写；</li>
<li>  Lambda 表达式的参数列表的数据类型可以省略不写，jvm编译器会进行上下文推断出，数据类型“类型推断”；</li>
</ul>
<p><strong>(1)、无参数，无返回值</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; System.out.println(<span class="string">&quot;测试&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>(2)、有一个参数，无返回值</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x) -&gt; System.out.println(x);</span><br></pre></td></tr></table></figure>

<p><strong>(3)、左侧只有一个参数，小括号可以省略不写</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x -&gt; System.out.println(x);</span><br></pre></td></tr></table></figure>

<p><strong>(4)、有两个以上参数，有返回值，并且Lambda 体中有多条语句</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; comparator = (x, y) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;测试&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> Integer.compare(x,y);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>(5)、若右侧Lambda体中，只有一条语句，return 和大括号都可以省略不写</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; Comparator = (x, y) -&gt; Integer.compare(x, y);</span><br></pre></td></tr></table></figure>

<p><strong>(6)、Lambda 表达式的参数列表的数据类型可以省略不写，JVM 在运行时，会自动根据绑定的抽象方法中的参数，进行数据类型推导</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Integer x, Integer y) -&gt; Integer.compare();</span><br></pre></td></tr></table></figure>

<h2 id="四、Lambda-表达式中变量作用域"><a href="#四、Lambda-表达式中变量作用域" class="headerlink" title="四、Lambda 表达式中变量作用域"></a>四、Lambda 表达式中变量作用域</h2><p>Java 中的变量捕获与变量隐藏：</p>
<ul>
<li>  <strong>变量捕获：</strong> 局部类和匿名内部类可以访问被 final 修饰的封闭块内的局部变量。</li>
<li>  <strong>变量隐藏：</strong> 在一个类中，子类中的成员变量如果和父类中的成员变量同名，那么即使他们类型不一样，只要名字一样，父类中的成员变量都会被隐藏。</li>
</ul>
<p>在局部类和匿名内部类都存在 <code>变量捕获</code> 与 <code>变量隐藏</code>，而在 <code>Lambda</code> 表达式中则只支持 <code>变量捕获</code>。</p>
<p><strong>下面是对这作用域得演示示例：</strong></p>
<p><strong>(1)、匿名内部类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VariableExample</span> &#123;</span><br><span class="line">    <span class="comment">/** 成员变量 */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;成员变量&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">innerClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 方法内部变量</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;方法内部变量&quot;</span>;</span><br><span class="line">        <span class="comment">// 使用匿名内部类创建线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="comment">// 匿名内部类内部变量</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;匿名内部类内部变量&quot;</span>;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">/* 访问变量 */</span></span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类输出：&quot;</span> + str1);</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类输出：&quot;</span> + str2);</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类输出：&quot;</span> + str3);</span><br><span class="line">                <span class="comment">/* 修改变量 */</span></span><br><span class="line">                str1 = <span class="string">&quot;修改访问成员变量&quot;</span>;</span><br><span class="line">                <span class="comment">// str2 = &quot;修改访问方法内部变量&quot;; // 不能进行修改，默认推导变量的修饰符 final</span></span><br><span class="line">                str3 = <span class="string">&quot;修改访问匿名内部类内部变量&quot;</span>;</span><br><span class="line">                <span class="comment">/* 在匿名内部类中定义和类外部变量一样名称的变量 */</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;重新命名成员变量&quot;</span>;</span><br><span class="line">                <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;重新命名方法内部变量&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Main 方法 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">VariableExample</span> <span class="variable">variableExample</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VariableExample</span>();</span><br><span class="line">        <span class="comment">// 匿名内部类</span></span><br><span class="line">        variableExample.innerClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(2)、Lambda 表达式：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VariableExample</span> &#123;</span><br><span class="line">    <span class="comment">/** 成员变量 */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;成员变量&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lambdaExpression</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 方法内部变量</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;方法内部变量&quot;</span>;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="comment">// Lambda 内部变量</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;Lambda 内部变量&quot;</span>;</span><br><span class="line">            <span class="comment">/* 访问变量 */</span></span><br><span class="line">            <span class="comment">// 访问成员变量</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Lambda 表达式输出：&quot;</span> + str1);</span><br><span class="line">            <span class="comment">// 访问方法内部变量</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Lambda 表达式输出：&quot;</span> + str2);</span><br><span class="line">            <span class="comment">// 访问匿名内部类内部变量</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Lambda 表达式输出：&quot;</span> + str3);</span><br><span class="line">            <span class="comment">/* 修改变量 */</span></span><br><span class="line">            str1 = <span class="string">&quot;修改访问成员变量&quot;</span>;</span><br><span class="line">            <span class="comment">// str2 = &quot;修改访问方法内部变量&quot;; // 不能进行修改，默认推导变量的修饰符 final</span></span><br><span class="line">            str3 = <span class="string">&quot;修改访问匿名内部类内部变量&quot;</span>;</span><br><span class="line">            <span class="comment">/* 在 Lambda 中定义和类外部变量一样名称的变量 */</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;重新命名成员变量&quot;</span>;</span><br><span class="line">            <span class="comment">// String str2 = &quot;重新命名方法内部变量&quot;; // 不能命名，lambda 不支持变量隐藏</span></span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Main 方法 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">VariableExample</span> <span class="variable">variableExample</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VariableExample</span>();</span><br><span class="line">        <span class="comment">// 匿名内部类</span></span><br><span class="line">        variableExample.innerClass();</span><br><span class="line">        <span class="comment">// Lambda 表达式</span></span><br><span class="line">        variableExample.lambdaExpression();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、Lambda-表达式方法重载问题"><a href="#五、Lambda-表达式方法重载问题" class="headerlink" title="五、Lambda 表达式方法重载问题"></a>五、Lambda 表达式方法重载问题</h2><p>       当使用 Lambda 表达式，调用一个类中的重载方法，且方法中的参数为都为函数接口，函数接口中定义的方法接收的参数类型相同，这时候 Lambda 是无法推断出要调用哪个方法。</p>
<p><strong>函数接口A：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInterfaceA</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(String param)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数接口B：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInterfaceB</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">pull</span><span class="params">(String param)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例，实现方法重载与测试的 Main 方法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaOverloadExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载方法A</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(MyInterfaceA myInterfaceA)</span> &#123;</span><br><span class="line">        myInterfaceA.push(<span class="string">&quot;hello 1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重载方法B</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(MyInterfaceB myInterfaceB)</span> &#123;</span><br><span class="line">        myInterfaceB.pull(<span class="string">&quot;Hello 2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Main 方法*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用匿名内部类</span></span><br><span class="line">        method(<span class="keyword">new</span> <span class="title class_">MyInterfaceA</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(String param)</span> &#123;</span><br><span class="line">                System.out.println(param);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        method(<span class="keyword">new</span> <span class="title class_">MyInterfaceB</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pull</span><span class="params">(String param)</span> &#123;</span><br><span class="line">                System.out.println(param);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 使用 Lambda 表达式</span></span><br><span class="line">        <span class="comment">//method(param -&gt; System.out.println(param)); // 编译器提示错误，表示无法推断使用哪个参数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面注掉的那部分代码，在编辑器中直接<code>提示错误</code>，很显然 <code>Lambda</code> 表达式<code>无法直接推断</code>出使用哪个类中的<code>重载方法</code>。其实，只要明确告诉 <code>Lambda</code> 表达式<code>使用哪个参数</code>，就可以很简单的解决问题，比如以上面的例子，在 <code>Lambda</code> 表达式使用 <code>method</code> 方法时，将<code>参数类型</code>转换为对应的<code>要使用的类型</code>就可以解决这个问题，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转换参数为 MyInterfaceA</span></span><br><span class="line">method((MyInterfaceA)param -&gt; System.out.println(param));</span><br><span class="line"><span class="comment">// 转换参数为 MyInterfaceB</span></span><br><span class="line">method((MyInterfaceB)param -&gt; System.out.println(param));</span><br></pre></td></tr></table></figure>

<p>按上面进行修改后就可以正常使用 Lambda 表达式了，如果不习惯也可以使用匿名内部类进行方法调用，内名内部类是没有相关问题的。</p>
<h2 id="六、Lambda-表达式方法引用"><a href="#六、Lambda-表达式方法引用" class="headerlink" title="六、Lambda 表达式方法引用"></a>六、Lambda 表达式方法引用</h2><p>       方法引用本质上就是对方法调用的简化，方法引用和函数式接口绑定，在使用过程中会创建函数式接口的实例，是结合 Lambda 表达式的一种特性。在应用过程中，方法引用常分为：</p>
<ul>
<li>  静态方法引用</li>
<li>  实例方法引用</li>
<li>  构造方法引用</li>
<li>  特定类型的任意对象实例方法引用</li>
</ul>
<blockquote>
<p>注意：在使用 Lmabda 方法引用时虽然能够简化代码，但是在实际开发中不可因需要简化代码而过度使用方法引用，因为他会在很大程度上降低代码可读性。</p>
</blockquote>
<h3 id="1、创建示例的实体类"><a href="#1、创建示例的实体类" class="headerlink" title="1、创建示例的实体类"></a>1、创建示例的实体类</h3><p>为了下面示例方便，我们首先创建一个 Person 实体类，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">/** 姓名 */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">/** 岁数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;name=&quot;</span> + name + <span class="string">&quot;,age=&quot;</span> + age + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、静态方法引用示例"><a href="#2、静态方法引用示例" class="headerlink" title="2、静态方法引用示例"></a>2、静态方法引用示例</h3><p>静态方法的引用的使用： <code>静态方法所在类</code>.<code>方法名称()</code> –&gt; <code>静态方法所在类</code> <code>::</code> <code>方法名称</code></p>
<p><strong>创建一个使用静态方法引用的示例类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticMethodExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 测试的静态方法 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compareAge</span><span class="params">(Person p1, Person p2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p1.getAge() - p2.getAge();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 Person 集合</span></span><br><span class="line">        List&lt;Person&gt; personList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Wangqin&quot;</span>,<span class="number">26</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Liming&quot;</span>,<span class="number">22</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alisi&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">31</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按岁数进行排序，使用静态方法引用</span></span><br><span class="line">        personList.sort(StaticMethodExample::compareAge);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、实例方法引用示例"><a href="#3、实例方法引用示例" class="headerlink" title="3、实例方法引用示例"></a>3、实例方法引用示例</h3><p>实例方法的引用的使用：<code>创建类型对应一个对象</code> –&gt; <code>对应应用</code> <code>::</code> <code>实例方法名称</code></p>
<p><strong>创建一个封装实例方法的类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonUtil</span>&#123;</span><br><span class="line">    <span class="comment">/** 测试的实例方法 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareAge</span><span class="params">(Person p1, Person p2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p1.getAge() - p2.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>创建一个使用实例方法引用的示例类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstanceMethodExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 Person 集合</span></span><br><span class="line">        List&lt;Person&gt; personList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Wangqin&quot;</span>,<span class="number">26</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Liming&quot;</span>,<span class="number">22</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alisi&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">31</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按岁数进行排序，</span></span><br><span class="line">        <span class="type">PersonUtil</span> <span class="variable">personUtil</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PersonUtil</span>();</span><br><span class="line">        <span class="comment">// 引用实例方法</span></span><br><span class="line">        personList.sort(personUtil::compareAge);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、构造方法引用示例"><a href="#4、构造方法引用示例" class="headerlink" title="4、构造方法引用示例"></a>4、构造方法引用示例</h3><p>构造方法的引用的使用：<code>绑定函数式接口</code></p>
<p><strong>创建一个函数式接口，且设置接收参数和 Person 的构造方法相同，返回 Person 对象的方法定义：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PersonConstructor</span>&#123;</span><br><span class="line">    Person <span class="title function_">initInstance</span><span class="params">(String name, <span class="type">int</span> age)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>创建一个使用构造方法引用的示例类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaConstructorMethodExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 Person 集合</span></span><br><span class="line">        List&lt;Person&gt; personList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Wangqin&quot;</span>, <span class="number">26</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Liming&quot;</span>, <span class="number">22</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alisi&quot;</span>, <span class="number">18</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jerry&quot;</span>, <span class="number">31</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造方法引用</span></span><br><span class="line">        <span class="type">PersonConstructor</span> <span class="variable">personConstructor</span> <span class="operator">=</span> Person::<span class="keyword">new</span>;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> personConstructor.initInstance(<span class="string">&quot;linda&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、特定类型的任意对象实例方法引用示例"><a href="#5、特定类型的任意对象实例方法引用示例" class="headerlink" title="5、特定类型的任意对象实例方法引用示例"></a>5、特定类型的任意对象实例方法引用示例</h3><p>特定类型的任意对象实例方法引用示例：<code>特定类型</code> <code>::</code> <code>特定类型的方法</code></p>
<p>以下是对特定类型的任意对象的实例方法的引用的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建字符串集合</span></span><br><span class="line">        List&lt;String&gt; strList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        strList.add(<span class="string">&quot;Jerry&quot;</span>);</span><br><span class="line">        strList.add(<span class="string">&quot;Mini&quot;</span>);</span><br><span class="line">        strList.add(<span class="string">&quot;Kary&quot;</span>);</span><br><span class="line">        strList.add(<span class="string">&quot;walls&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用集合的sort方法，按照String的compareToIgnoreCase进行排序（比较字符串hash值）</span></span><br><span class="line">        strList.sort(String::compareToIgnoreCase);</span><br><span class="line">        System.out.println(strList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里根据定义的集合 <code>strList</code> 去推导目标类型参数值，如果<code>不符合</code>后面传入的方法引用所对应的类型，将报错。该方法参考等效 <code>Lambda</code> 表达式 <code>String::compareToIgnoreCase</code> 的参数列表 <code>(String a, String b)</code>，其中 a 和 b 是用于更好地描述这个例子中的任意名称。方法引用将调用该方法 <code>a.compareToIgnoreCase(b)</code>。</p>
<blockquote>
<p>转自：<a target="_blank" rel="noopener" href="http://www.mydlq.club/article/89/">http://www.mydlq.club/article/89/</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://moqiang02.github.io/2022/11/02/Java8%E4%B8%AD%E4%BD%BF%E7%94%A8Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AE%80%E5%8C%96%E4%BB%A3%E7%A0%81/" data-id="cla0v65vo00j7g0v1djct6o7d" data-title="Java8中使用Lambda表达式简化代码(小豆丁技术栈)" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaSE/" rel="tag">JavaSE</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/11/02/SpringBoot-%E5%A4%9A%E7%A7%8D%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E5%BC%8F/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          SpringBoot 多种读取配置文件中参数的方式(小豆丁技术栈)
        
      </div>
    </a>
  
  
    <a href="/2022/11/02/Java8%E4%B8%AD%E6%96%B0%E5%A2%9E%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4API%E7%9A%84%E4%BD%BF%E7%94%A8/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">Java8中新增日期时间API的使用(小豆丁技术栈)</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/android/">android</a><span class="category-list-count">255</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/apache/">apache</a><span class="category-list-count">27</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/flutter/">flutter</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/github%E5%8D%9A%E5%AE%A2/">github博客</a><span class="category-list-count">19</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/go/">go</a><span class="category-list-count">26</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/html-css/">html+css</a><span class="category-list-count">27</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iis/">iis</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">84</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/">javascript</a><span class="category-list-count">124</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/kotlin/">kotlin</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">68</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mac/">mac</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/memcached/">memcached</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mongodb/">mongodb</a><span class="category-list-count">19</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a><span class="category-list-count">74</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/">nginx</a><span class="category-list-count">41</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/nodejs/">nodejs</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/php/">php</a><span class="category-list-count">185</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a><span class="category-list-count">44</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%B6%E5%AE%83/">其它</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a><span class="category-list-count">51</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/">开源项目</a><span class="category-list-count">73</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/">生活随笔</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93/">量化交易</a><span class="category-list-count">3</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/AndroidStudio/" style="font-size: 13.16px;">AndroidStudio</a> <a href="/tags/AndroidUI/" style="font-size: 20px;">AndroidUI</a> <a href="/tags/Android%E4%BA%8B%E4%BB%B6%E6%8B%A6%E6%88%AA/" style="font-size: 11.05px;">Android事件拦截</a> <a href="/tags/Android%E5%BC%80%E6%BA%90/" style="font-size: 16.84px;">Android开源</a> <a href="/tags/CI/" style="font-size: 15.26px;">CI</a> <a href="/tags/CURL/" style="font-size: 12.63px;">CURL</a> <a href="/tags/DEDE/" style="font-size: 17.37px;">DEDE</a> <a href="/tags/Docker/" style="font-size: 14.21px;">Docker</a> <a href="/tags/Flask/" style="font-size: 10.53px;">Flask</a> <a href="/tags/JavaSE/" style="font-size: 18.42px;">JavaSE</a> <a href="/tags/Laravel/" style="font-size: 16.84px;">Laravel</a> <a href="/tags/Maven/" style="font-size: 11.58px;">Maven</a> <a href="/tags/MybatisPlus/" style="font-size: 11.05px;">MybatisPlus</a> <a href="/tags/Puppeteer/" style="font-size: 14.74px;">Puppeteer</a> <a href="/tags/SVN/" style="font-size: 10px;">SVN</a> <a href="/tags/Selenium/" style="font-size: 11.58px;">Selenium</a> <a href="/tags/SpringBoot/" style="font-size: 19.47px;">SpringBoot</a> <a href="/tags/Thinkphp/" style="font-size: 10px;">Thinkphp</a> <a href="/tags/UEditor/" style="font-size: 11.58px;">UEditor</a> <a href="/tags/VMware/" style="font-size: 12.11px;">VMware</a> <a href="/tags/Vue/" style="font-size: 18.95px;">Vue</a> <a href="/tags/WebSocket/" style="font-size: 12.63px;">WebSocket</a> <a href="/tags/ecshop/" style="font-size: 14.21px;">ecshop</a> <a href="/tags/scrapy/" style="font-size: 13.68px;">scrapy</a> <a href="/tags/smarty/" style="font-size: 12.11px;">smarty</a> <a href="/tags/socket/" style="font-size: 14.21px;">socket</a> <a href="/tags/sphinx/" style="font-size: 11.58px;">sphinx</a> <a href="/tags/vagrant/" style="font-size: 12.11px;">vagrant</a> <a href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" style="font-size: 11.05px;">微服务</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/" style="font-size: 15.26px;">数据传输</a> <a href="/tags/%E6%AD%A3%E5%88%99/" style="font-size: 11.58px;">正则</a> <a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size: 15.79px;">消息队列</a> <a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size: 17.89px;">爬虫</a> <a href="/tags/%E9%9B%86%E7%BE%A4/" style="font-size: 16.32px;">集群</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/07/16/%E7%8E%8B%E6%B5%B7%E5%85%89%EF%BC%9A%E6%94%BF%E4%BA%89%E4%B8%8E%E6%9D%83%E4%BA%89-%E9%AB%98%E9%A5%B6%E4%BA%8B%E4%BB%B6%E8%B5%B7%E5%9B%A0%E5%86%8D%E8%A7%A3%E8%AF%BB/">王海光：政争与权争-高饶事件起因再解读</a>
          </li>
        
          <li>
            <a href="/2025/06/19/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82Vue%E4%B8%AD%E7%9A%84Mixin%E6%B7%B7%E5%85%A5/">彻底搞懂Vue中的Mixin混入</a>
          </li>
        
          <li>
            <a href="/2025/03/14/%E5%A6%82%E4%BD%95%E5%8F%91%E5%B8%83jar%E5%8C%85%E5%88%B0maven%E4%B8%AD%E5%A4%AE%E4%BB%93%E5%BA%93/">如何发布jar包到maven中央仓库</a>
          </li>
        
          <li>
            <a href="/2025/03/14/%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8-Redis-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97%EF%BC%9F/">怎么使用Redis实现一个延时队列？</a>
          </li>
        
          <li>
            <a href="/2025/03/11/%E5%A4%9A%E5%B1%82%E5%B5%8C%E5%A5%97%E7%9A%84div%E4%B8%94%E9%AB%98%E5%BA%A6%E9%83%BD%E4%B8%8D%E5%9B%BA%E5%AE%9A%EF%BC%8C%E8%AE%A9%E5%AD%90div%E5%86%85%E5%AE%B9%E6%BB%9A%E5%8A%A8/">多层嵌套的div且高度都不固定，让子div内容滚动</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 moqiang<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>

<!-- rex -->

<script src="/js/toc.js"></script>


  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>