<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>RabbitMQ从新手到熟悉（二）一文带你SpringBoot+RabbitMQ方式收发消息 | 自强不息</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="楔子本篇是消息队列RabbitMQ的第二弹。 上一篇的结尾我也预告了本篇的内容：利用RabbitTemplate和注解进行收发消息，还有一个我临时加上的内容：消息的序列化转换。 本篇会和SpringBoot做整合，采用自动配置的方式进行开发，我们只需要声明RabbitMQ地址就可以了，关于各种创建连接关闭连接的事都由Spring帮我们了~ 交给Spring帮我们管理连接可以让我们专注于业务逻辑，就">
<meta property="og:type" content="article">
<meta property="og:title" content="RabbitMQ从新手到熟悉（二）一文带你SpringBoot+RabbitMQ方式收发消息">
<meta property="og:url" content="http://moqiang02.github.io/2022/09/29/RabbitMQ%E4%BB%8E%E6%96%B0%E6%89%8B%E5%88%B0%E7%86%9F%E6%82%89%EF%BC%88%E4%BA%8C%EF%BC%89%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0SpringBoot-RabbitMQ%E6%96%B9%E5%BC%8F%E6%94%B6%E5%8F%91%E6%B6%88%E6%81%AF/index.html">
<meta property="og:site_name" content="自强不息">
<meta property="og:description" content="楔子本篇是消息队列RabbitMQ的第二弹。 上一篇的结尾我也预告了本篇的内容：利用RabbitTemplate和注解进行收发消息，还有一个我临时加上的内容：消息的序列化转换。 本篇会和SpringBoot做整合，采用自动配置的方式进行开发，我们只需要声明RabbitMQ地址就可以了，关于各种创建连接关闭连接的事都由Spring帮我们了~ 交给Spring帮我们管理连接可以让我们专注于业务逻辑，就">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://moqiang02.github.io/images/RabbitMQ%E4%BB%8E%E6%96%B0%E6%89%8B%E5%88%B0%E7%86%9F%E6%82%892/0.png">
<meta property="og:image" content="http://moqiang02.github.io/images/RabbitMQ%E4%BB%8E%E6%96%B0%E6%89%8B%E5%88%B0%E7%86%9F%E6%82%892/1.png">
<meta property="og:image" content="http://moqiang02.github.io/images/RabbitMQ%E4%BB%8E%E6%96%B0%E6%89%8B%E5%88%B0%E7%86%9F%E6%82%892/2.png">
<meta property="og:image" content="http://moqiang02.github.io/images/RabbitMQ%E4%BB%8E%E6%96%B0%E6%89%8B%E5%88%B0%E7%86%9F%E6%82%892/3.png">
<meta property="og:image" content="http://moqiang02.github.io/images/RabbitMQ%E4%BB%8E%E6%96%B0%E6%89%8B%E5%88%B0%E7%86%9F%E6%82%892/4.png">
<meta property="og:image" content="http://moqiang02.github.io/images/RabbitMQ%E4%BB%8E%E6%96%B0%E6%89%8B%E5%88%B0%E7%86%9F%E6%82%892/5.png">
<meta property="og:image" content="http://moqiang02.github.io/images/RabbitMQ%E4%BB%8E%E6%96%B0%E6%89%8B%E5%88%B0%E7%86%9F%E6%82%892/6.png">
<meta property="og:image" content="http://moqiang02.github.io/images/RabbitMQ%E4%BB%8E%E6%96%B0%E6%89%8B%E5%88%B0%E7%86%9F%E6%82%892/7.png">
<meta property="og:image" content="http://moqiang02.github.io/images/RabbitMQ%E4%BB%8E%E6%96%B0%E6%89%8B%E5%88%B0%E7%86%9F%E6%82%892/8.png">
<meta property="article:published_time" content="2022-09-29T02:27:31.000Z">
<meta property="article:modified_time" content="2022-11-21T06:33:03.422Z">
<meta property="article:author" content="moqiang">
<meta property="article:tag" content="消息队列">
<meta property="article:tag" content="SpringBoot">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://moqiang02.github.io/images/RabbitMQ%E4%BB%8E%E6%96%B0%E6%89%8B%E5%88%B0%E7%86%9F%E6%82%892/0.png">
  
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">自强不息</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://moqiang02.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-RabbitMQ从新手到熟悉（二）一文带你SpringBoot-RabbitMQ方式收发消息" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/09/29/RabbitMQ%E4%BB%8E%E6%96%B0%E6%89%8B%E5%88%B0%E7%86%9F%E6%82%89%EF%BC%88%E4%BA%8C%EF%BC%89%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0SpringBoot-RabbitMQ%E6%96%B9%E5%BC%8F%E6%94%B6%E5%8F%91%E6%B6%88%E6%81%AF/" class="article-date">
  <time class="dt-published" datetime="2022-09-29T02:27:31.000Z" itemprop="datePublished">2022-09-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      RabbitMQ从新手到熟悉（二）一文带你SpringBoot+RabbitMQ方式收发消息
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      

          <!-- rex -->
          
            <!-- 文章目录开始 -->
            
              <div id="toc" class="toc-article">
              <strong class="toc-title" style="cursor:pointer">目录</strong>
              <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A5%94%E5%AD%90"><span class="toc-number">1.</span> <span class="toc-text">楔子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%F0%9F%94%8D%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="toc-number">2.</span> <span class="toc-text">1. 🔍环境配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%F0%9F%93%95%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8ERabbitTemplate"><span class="toc-number">3.</span> <span class="toc-text">2. 📕生产者与RabbitTemplate</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%F0%9F%93%97%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%8ERabbitListener"><span class="toc-number">4.</span> <span class="toc-text">3. 📗消费者与RabbitListener</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%F0%9F%93%96SpringBoot-%E5%90%AF%E5%8A%A8%EF%BC%81"><span class="toc-number">5.</span> <span class="toc-text">4. 📖SpringBoot 启动！</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%F0%9F%93%98-RabbitListener%E4%B8%8E-RabbitHandler"><span class="toc-number">6.</span> <span class="toc-text">5. 📘@RabbitListener与@RabbitHandler</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%F0%9F%93%99%E6%B6%88%E6%81%AF%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E8%BD%AC%E6%8D%A2"><span class="toc-number">7.</span> <span class="toc-text">6. 📙消息的序列化转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E8%AE%B0"><span class="toc-number">8.</span> <span class="toc-text">后记</span></a></li></ol>
              </div>
            
            <!-- 文章目录结束 -->	  
          

        <h2 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h2><p>本篇是消息队列RabbitMQ的第二弹。</p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/6856571028496351239" title="https://juejin.im/post/6856571028496351239">上一篇</a>的结尾我也预告了本篇的内容：利用RabbitTemplate和注解进行收发消息，还有一个我临时加上的内容：消息的序列化转换。</p>
<p>本篇会和SpringBoot做整合，采用自动配置的方式进行开发，我们只需要声明RabbitMQ地址就可以了，关于各种创建连接关闭连接的事都由Spring帮我们了~</p>
<p>交给Spring帮我们管理连接可以让我们专注于业务逻辑，就像声明式事务一样易用，方便又高效。<span id="more"></span></p>
<p><strong>本文代码：</strong> <a target="_blank" rel="noopener" href="https://gitee.com/he-erduo/spring-boot-learning-demo">码云地址</a> <a target="_blank" rel="noopener" href="https://github.com/he-erduo/spring-boot-learning-demo">GitHub地址</a></p>
<p><strong>Tip</strong>：上一篇的代码都放在<code>prototype</code>包下，本篇的代码都放在<code>auto</code>包下面。</p>
<h2 id="1-🔍环境配置"><a href="#1-🔍环境配置" class="headerlink" title="1. 🔍环境配置"></a>1. 🔍环境配置</h2><p>第一节我们先来搞一下环境的配置，上一篇中我们已经引入了自动配置的包，我们既然使用了自动配置的方式，那<code>RabbitMQ</code>的连接信息我们直接放在配置文件中就行了，就像我们需要用到JDBC连接的时候去配置一下<code>DataSource</code>一样。</p>
<p><img src="/images/RabbitMQ%E4%BB%8E%E6%96%B0%E6%89%8B%E5%88%B0%E7%86%9F%E6%82%892/0.png"></p>
<p>如图所示，我们只需要指明一下连接的IP+端口号和用户名密码就行了，这里我用的是默认的用户名与密码，不写的话默认也都是guest，端口号也是默认5672。</p>
<p>主要我们需要看一下手动确认消息的配置，需要配置成<code>manual</code>才是手动确认，日后还会有其他的配置项，眼下我们配置这一个就可以了。</p>
<p>接下来我们要配置一个<code>Queue</code>，上一篇中我们往一个名叫<code>erduo</code>的队列中发送消息，当时是我们手动定义的此队列，这里我们也需要手动配置，声明一个<code>Bean</code>就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitmqConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">erduo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 其三个参数：durable exclusive autoDelete</span></span><br><span class="line">        <span class="comment">// 一般只设置一下持久化即可</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;erduo&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就这么简单声明一下就可以了，当然了<code>RabbitMQ</code>毕竟是一个独立的组件，如果你在<code>RabbitMQ</code>中通过其他方式已经创建过一个名叫<code>erduo</code>的队列了，你这里也可以不声明，这里起到的一个效果就是如果你没有这个队列，会按照你声明的方式帮你创建这个队列。</p>
<p>配置完环境之后，我们就可以以SpringBoot的方式来编写生产者和消费者了。</p>
<h2 id="2-📕生产者与RabbitTemplate"><a href="#2-📕生产者与RabbitTemplate" class="headerlink" title="2. 📕生产者与RabbitTemplate"></a>2. 📕生产者与RabbitTemplate</h2><p>和上一篇的节奏一样，我们先来编写生产者，不过这次我要引入一个新的工具：<code>RabbitTemplate</code>。</p>
<p>听它的这个名字就知道，又是一个拿来即用的工具类，Spring家族这点就很舒服，什么东西都给你封装一遍，让你用起来更方便更顺手。</p>
<p><code>RabbitTemplate</code>实现了标准AmqpTemplate接口，功能大致可以分为发送消息和接受消息。</p>
<p>我们这里是在生产者中来用，主要就是使用它的发送消息功能：<code>send</code>和<code>convertAndSend</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送消息到默认的Exchange，使用默认的routing key</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">send</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用指定的routing key发送消息到默认的exchange</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String routingKey, Message message)</span> <span class="keyword">throws</span> AmqpException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用指定的routing key发送消息到指定的exchange</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String exchange, String routingKey, Message message)</span> <span class="keyword">throws</span> AmqpException;</span><br></pre></td></tr></table></figure>

<p><code>send</code>方法是发送byte数组的数据的模式，这里代表消息内容的对象是<code>Message</code>对象，它的构造方法就是传入byte数组数据，所以我们需要把我们的数据转成byte数组然后构造成一个<code>Message</code>对象再进行发送。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object类型，可以传入POJO</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">convertAndSend</span><span class="params">(Object message)</span> <span class="keyword">throws</span> AmqpException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">convertAndSend</span><span class="params">(String routingKey, Object message)</span> <span class="keyword">throws</span> AmqpException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">convertAndSend</span><span class="params">(String exchange, String routingKey, Object message)</span> <span class="keyword">throws</span> AmqpException;</span><br></pre></td></tr></table></figure>

<p><code>convertAndSend</code>方法是可以传入POJO对象作为参数，底层是有一个<code>MessageConverter</code>帮我们自动将数据转换成byte类型或String或序列化类型。</p>
<p>所以这里支持的传入对象也只有三种：byte类型，String类型和实现了<code>Serializable</code>接口的POJO。</p>
<p>介绍完了，我们可以看一下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component(&quot;rabbitProduce&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitProduce</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello 我是作者和耳朵，欢迎关注我。&quot;</span> + LocalDateTime.now().toString();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Message content : &quot;</span> + message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定消息类型</span></span><br><span class="line">        <span class="type">MessageProperties</span> <span class="variable">props</span> <span class="operator">=</span> MessagePropertiesBuilder.newInstance()</span><br><span class="line">                .setContentType(MessageProperties.CONTENT_TYPE_TEXT_PLAIN).build();</span><br><span class="line"></span><br><span class="line">        rabbitTemplate.send(Producer.QUEUE_NAME,<span class="keyword">new</span> <span class="title class_">Message</span>(message.getBytes(StandardCharsets.UTF_8),props));</span><br><span class="line">        System.out.println(<span class="string">&quot;消息发送完毕。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">convertAndSend</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Message content : &quot;</span> + user);</span><br><span class="line"></span><br><span class="line">        rabbitTemplate.convertAndSend(Producer.QUEUE_NAME,user);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息发送完毕。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我特意写明了两个例子，一个用来测试send，另一个用来测试convertAndSend。</p>
<p><code>send</code>方法里我们看下来和之前的代码是几乎一样的，定义一个消息，然后直接send，但是这个构造消息的构造方法可能比我们想的要多一个参数，我们原来说的只要把数据转成二进制数组放进去即可，现在看来还要多放一个参数了。</p>
<p><code>MessageProperties</code>，是的我们需要多放一个<code>MessageProperties</code>对象，从他的名字我们也可以看出它的功能就是附带一些参数，但是某些参数是少不了的，不带不行。</p>
<p>比如我的代码这里就是设置了一下消息的类型，消息的类型有很多种可以是二进制类型，文本类型，或者序列化类型，JSON类型，我这里设置的就是文本类型，指定类型是必须的，也可以为我们拿到消息之后要将消息转换成什么样的对象提供一个参考。</p>
<p><code>convertAndSend</code>方法就要简单太多，这里我放了一个User对象拿来测试用，直接指定队列然后放入这个对象即可。</p>
<p><strong>Tips</strong>：User必须实现<code>Serializable</code>接口，不然的话调用此方法的时候会抛出<code>IllegalArgumentException</code>异常。</p>
<p>代码完成之后我们就可以调用了，这里我写一个测试类进行调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitProduceTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitProduce rabbitProduce;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendSimpleMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        rabbitProduce.send();</span><br><span class="line">        rabbitProduce.convertAndSend();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下图~</p>
<p><img src="/images/RabbitMQ%E4%BB%8E%E6%96%B0%E6%89%8B%E5%88%B0%E7%86%9F%E6%82%892/1.png"></p>
<p>同时在控制台使用命令<code>rabbitmqctl.bat list_queues</code>查看队列-<code>erduo</code>现在的情况：</p>
<p><img src="/images/RabbitMQ%E4%BB%8E%E6%96%B0%E6%89%8B%E5%88%B0%E7%86%9F%E6%82%892/2.png"></p>
<p>如此一来，我们的生产者测试就算完成了，现在消息队列里两条消息了，而且消息类型肯定不一样，一个是我们设置的文本类型，一个是自动设置的序列化类型。</p>
<h2 id="3-📗消费者与RabbitListener"><a href="#3-📗消费者与RabbitListener" class="headerlink" title="3. 📗消费者与RabbitListener"></a>3. 📗消费者与RabbitListener</h2><p>既然队列里面已经有消息了，接下来我们就要看我们该如何通过新的方式拿到消息并消费与确认了。</p>
<p>消费者这里我们要用到<code>@RabbitListener</code>来帮我们拿到指定队列消息，它的用法很简单也很复杂，我们可以先来说简单的方式，直接放到方法上，指定监听的队列就行了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component(&quot;rabbitConsumer&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = Producer.QUEUE_NAME)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Message content : &quot;</span> + message);</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="literal">false</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息已确认&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码就代表<code>onMessage</code>方法会处理erduo(Producer.QUEUE_NAME是常量字符串”erduo”)队列中的消息。</p>
<p>我们可以看到这个方法里面有两个参数，<code>Message</code>和<code>Channel</code>，如果用不到<code>Channel</code>可以不写此参数，但是<code>Message</code>消息一定是要的，它代表了消息本身。</p>
<p>我们可以想想，我们的程序从<code>RabbitMQ</code>之中拉回一条条消息之后，要以怎么样的方式展示给我们呢？</p>
<p>没错，就是封装为一个个<code>Message</code>对象，这里面放入了一条消息的所有信息，数据结构是什么样一会我一run你就能看到了。</p>
<p>同时这里我们使用<code>Channel</code>做一个消息确认的操作，这里的DeliveryTag代表的是这个消息在队列中的序号，这个信息存放在<code>MessageProperties</code>中。</p>
<h2 id="4-📖SpringBoot-启动！"><a href="#4-📖SpringBoot-启动！" class="headerlink" title="4. 📖SpringBoot 启动！"></a>4. 📖SpringBoot 启动！</h2><p>编写完生产者和消费者，同时已经运行过生产者往消息队列里面放了两条信息，接下来我们可以直接启动消息，查看消费情况：</p>
<p><img src="/images/RabbitMQ%E4%BB%8E%E6%96%B0%E6%89%8B%E5%88%B0%E7%86%9F%E6%82%892/3.png"></p>
<p>在我红色框线标记的地方可以看到，因为我们有了消费者所以项目启动后先和RabbitMQ建立了一个连接进行监听队列。</p>
<p>随后就开始消费我们队列中的两条消息：</p>
<p>第一条信息是<code>contentType=text/plain</code>类型，所以直接就在控制台上打印出了具体内容。</p>
<p>第二条信息是<code>contentType=application/x-java-serialized-object</code>，在打印的时候只打印了一个内存地址+字节大小。</p>
<p>不管怎么说，数据我们是拿到了，也就是代表我们的消费是没有问题的，同时也都进行了消息确认操作，从数据上看，整个消息可以分为两部分：<code>body</code>和<code>MessageProperties</code>。</p>
<p>我们可以单独使用一个注解拿到这个body的内容 - <code>@Payload</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = Producer.QUEUE_NAME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(<span class="meta">@Payload</span> String body, Channel channel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Message content : &quot;</span> + body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以单独使用一个注解拿到<code>MessageProperties</code>的headers属性，headers属性在截图里也可以看到，只不过是个空的 - @Headers。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = Producer.QUEUE_NAME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(<span class="meta">@Payload</span> String body, <span class="meta">@Headers</span> Map&lt;String,Object&gt; headers)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Message content : &quot;</span> + body);</span><br><span class="line">    System.out.println(<span class="string">&quot;Message headers : &quot;</span> + headers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个注解都算是扩展知识，我还是更喜欢直接拿到全部，全都要！！！</p>
<p>上面我们已经完成了消息的发送与消费，整个过程我们可以再次回想一下，一切都和我画的这张图上一样的轨迹：</p>
<p><img src="/images/RabbitMQ%E4%BB%8E%E6%96%B0%E6%89%8B%E5%88%B0%E7%86%9F%E6%82%892/4.png"></p>
<p>只不过我们一直没有指定<code>Exchage</code>一直使用的默认路由，希望大家好好记住这张图。</p>
<h2 id="5-📘-RabbitListener与-RabbitHandler"><a href="#5-📘-RabbitListener与-RabbitHandler" class="headerlink" title="5. 📘@RabbitListener与@RabbitHandler"></a>5. 📘@RabbitListener与@RabbitHandler</h2><p>下面再来补一些知识点，有关<code>@RabbitListener</code>与<code>@RabbitHandler</code>。</p>
<p><code>@RabbitListener</code>上面我们已经简单的进行了使用，稍微扩展一下它其实是可以监听多个队列的，就像这样：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@RabbitListener(queues = &#123; <span class="string">&quot;queue1&quot;</span>, <span class="string">&quot;queue2&quot;</span> &#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span>(<span class="params">Message message, Channel channel</span>) throws Exception</span> &#123;</span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="string">&quot;Message content : &quot;</span> + message);</span><br><span class="line">    channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="literal">false</span>);</span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="string">&quot;消息已确认&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一些其他的特性如绑定之类的，这里不再赘述因为太硬编码了一般用不上。</p>
<p>下面来说说这节要主要讲的一个特性：@RabbitListener和@RabbitHandler的搭配使用。</p>
<p>前面我们没有提到，<code>@RabbitListener</code>注解其实是可以注解在类上的，这个注解在类上标志着这个类监听某个队列或某些队列。</p>
<p>这两个注解的搭配使用就要让<code>@RabbitListener</code>注解在类上，然后用<code>@RabbitHandler</code>注解在方法上，根据方法参数的不同自动识别并去消费，写个例子给大家看一看更直观一些。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component(&quot;rabbitConsumer&quot;)</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = Producer.QUEUE_NAME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(<span class="meta">@Payload</span> String message)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Message content : &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(<span class="meta">@Payload</span> User user)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Message content : &quot;</span> + user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大家可以看看这个例子，我们先用<code>@RabbitListener</code>监听<code>erduo</code>队列中的消息，然后使用<code>@RabbitHandler</code>注解了两个方法。</p>
<ul>
<li><p>  <strong>第一个</strong>方法的body类型是String类型，这就代表着这个方法只能处理文本类型的消息。</p>
</li>
<li><p>  <strong>第二个方法</strong>的body类型是User类型，这就代表着这个方法只能处理序列化类型且为User类型的消息。</p>
</li>
</ul>
<p>这两个方法正好对应着我们第二节中测试类会发送的两种消息，所以我们往RabbitMQ中发送两条测试消息，用来测试这段代码，看看效果：</p>
<p><img src="/images/RabbitMQ%E4%BB%8E%E6%96%B0%E6%89%8B%E5%88%B0%E7%86%9F%E6%82%892/5.png"></p>
<p>都在控制台上如常打印了，如果<code>@RabbitHandler</code>注解的方法中没有一个的类型可以和你消息的类型对的上，比如消息都是byte数组类型，这里没有对应的方法去接收，系统就会在控制台不断的报错，如果你出现这个情况就证明你类型写的不正确。</p>
<p>假设你的<code>erduo</code>队列中会出现三种类型的消息：byte，文本和序列化，那你就必须要有对应的处理这三种消息的方法，不然消息发过来的时候就会因为无法正确转换而报错。</p>
<p>而且使用了<code>@RabbitHandler</code>注解之后就不能再和之前一样使用<code>Message</code>做接收类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Message content : &quot;</span> + message);</span><br><span class="line">    channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="literal">false</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;消息已确认&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样写的话会报类型转换异常的，所以二者选其一。</p>
<p>同时上文我的<code>@RabbitHandler</code>没有进行消息确认，大家可以自己试一下进行消息确认。</p>
<h2 id="6-📙消息的序列化转换"><a href="#6-📙消息的序列化转换" class="headerlink" title="6. 📙消息的序列化转换"></a>6. 📙消息的序列化转换</h2><p>通过上文我们已经知道，能被自动转换的对象只有<code>byte[]</code>、<code>String</code>、<code>java序列化对象</code>(实现了Serializable接口的对象)，但是并不是所有的Java对象都会去实现Serializable接口，而且序列化的过程中使用的是JDK自带的序列化方法，效率低下。</p>
<p>所以我们更普遍的做法是：使用Jackson先将数据转换成JSON格式发送给<code>RabbitMQ</code>，再接收消息的时候再用Jackson将数据反序列化出来。</p>
<p>这样做可以完美解决上面的痛点：消息对象既不必再去实现Serializable接口，也有比较高的效率(Jackson序列化效率业界应该是最好的了)。</p>
<p>默认的消息转换方案是消息转换顶层接口-<code>MessageConverter</code>的一个子类：<code>SimpleMessageConverter</code>，我们如果要换到另一个消息转换器只需要替换掉这个转换器就行了。</p>
<p><img src="/images/RabbitMQ%E4%BB%8E%E6%96%B0%E6%89%8B%E5%88%B0%E7%86%9F%E6%82%892/6.png"></p>
<p>上图是<code>MessageConverter</code>结构树的结构树，可以看到除了<code>SimpleMessageConverter</code>之外还有一个<code>Jackson2JsonMessageConverter</code>，我们只需要将它定义为Bean，就可以直接使用这个转换器了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageConverter <span class="title function_">jackson2JsonMessageConverter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>(jacksonObjectMapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以了，这里的<code>jacksonObjectMapper</code>可以不传入，但是默认的<code>ObjectMapper</code>方案对JDK8的时间日期序列化会不太友好，具体可以参考我的上一篇文章：<a target="_blank" rel="noopener" href="https://juejin.im/post/6854573211528249357" title="https://juejin.im/post/6854573211528249357">从LocalDateTime序列化探讨全局一致性序列化</a>，总的来说就是定义了自己的<code>ObjectMapper</code>。</p>
<p>同时为了接下来测试方便，我又定义了一个专门测试JSON序列化的队列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">erduoJson</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 其三个参数：durable exclusive autoDelete</span></span><br><span class="line">    <span class="comment">// 一般只设置一下持久化即可</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;erduo_json&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如此之后就可以进行测试了，先是<strong>生产者代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendObject</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Client</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Client</span>();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;Message content : &quot;</span> + client);</span><br><span class="line"></span><br><span class="line">    rabbitTemplate.convertAndSend(RabbitJsonConsumer.JSON_QUEUE,client);</span><br><span class="line">    System.out.println(<span class="string">&quot;消息发送完毕。&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我定义了一个<code>Client</code>对象，它和之前测试使用的User对象成员变量都是一样的，不一样的是它没有实现Serializable接口。</p>
<p>同时为了保留之前的测试代码，我又新建了一个<code>RabbitJsonConsumer</code>，用于测试JSON序列化的相关消费代码，里面定义了一个静态变量：<code>JSON_QUEUE = &quot;erduo_json&quot;</code>;</p>
<p>所以这段代码是将<code>Client</code>对象作为消息发送到<code>&quot;erduo_json&quot;</code>队列中去，随后我们在测试类中run一下进行一次发送。</p>
<p>紧着是<strong>消费者代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component(&quot;rabbitJsonConsumer&quot;)</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = RabbitJsonConsumer.JSON_QUEUE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitJsonConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">JSON_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;erduo_json&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Client client, <span class="meta">@Headers</span> Map&lt;String,Object&gt; headers, Channel channel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Message content : &quot;</span> + client);</span><br><span class="line">        System.out.println(<span class="string">&quot;Message headers : &quot;</span> + headers);</span><br><span class="line">        channel.basicAck((Long) headers.get(AmqpHeaders.DELIVERY_TAG),<span class="literal">false</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息已确认&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了上文的经验之后，这段代码理解起来也是很简单了吧，同时给出了上一节没写的如何在<code>@RabbitHandler</code>模式下进行消息签收。</p>
<p>我们直接来看看效果：</p>
<p><img src="/images/RabbitMQ%E4%BB%8E%E6%96%B0%E6%89%8B%E5%88%B0%E7%86%9F%E6%82%892/7.png"><br><img src="/images/RabbitMQ%E4%BB%8E%E6%96%B0%E6%89%8B%E5%88%B0%E7%86%9F%E6%82%892/8.png"></p>
<p>在打印的Headers里面，往后翻可以看到<code>contentType=application/json</code>，这个<code>contentType</code>是表明了消息的类型，这里正是说明我们新的消息转换器生效了，将所有消息都转换成了JSON类型。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这两篇讲完了<code>RabbitMQ</code>的基本收发消息，包括手动配置和自动配置的两种方式，这些大家仔细研读之后应该会对<code>RabbitMQ</code>收发消息没什么疑问了~</p>
<p>不过我们一直以来发消息时都是使用默认的交换机，下篇将会讲述一下<code>RabbitMQ</code>的几种交换机类型，以及其使用方式。</p>
<p>讲完了交换机之后，这些<code>RabbitMQ</code>的常用概念基本就完善了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://moqiang02.github.io/2022/09/29/RabbitMQ%E4%BB%8E%E6%96%B0%E6%89%8B%E5%88%B0%E7%86%9F%E6%82%89%EF%BC%88%E4%BA%8C%EF%BC%89%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0SpringBoot-RabbitMQ%E6%96%B9%E5%BC%8F%E6%94%B6%E5%8F%91%E6%B6%88%E6%81%AF/" data-id="cla0v65zj00wtg0v1hr2aam2r" data-title="RabbitMQ从新手到熟悉（二）一文带你SpringBoot+RabbitMQ方式收发消息" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" rel="tag">消息队列</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/09/29/RabbitMQ%E4%BB%8E%E6%96%B0%E6%89%8B%E5%88%B0%E7%86%9F%E6%82%89%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%8A%E6%89%8B%E4%BA%86RabbitMQ%EF%BC%9F%E5%86%8D%E6%9D%A5%E7%9C%8B%E7%9C%8B%E5%AE%83%E7%9A%84%E4%BA%A4%E6%8D%A2%E6%9C%BA-Exchange-%E5%90%A7/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          RabbitMQ从新手到熟悉（三）上手了RabbitMQ？再来看看它的交换机(Exchange)吧
        
      </div>
    </a>
  
  
    <a href="/2022/09/29/RabbitMQ%E4%BB%8E%E6%96%B0%E6%89%8B%E5%88%B0%E7%86%9F%E6%82%89%EF%BC%88%E4%B8%80%EF%BC%89%E6%B2%A1%E7%94%A8%E8%BF%87%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9F%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E4%BD%93%E9%AA%8CRabbitMQ%E6%94%B6%E5%8F%91%E6%B6%88%E6%81%AF/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">RabbitMQ从新手到熟悉（一）没用过消息队列？一文带你体验RabbitMQ收发消息</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/android/">android</a><span class="category-list-count">255</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/apache/">apache</a><span class="category-list-count">27</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/flutter/">flutter</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/github%E5%8D%9A%E5%AE%A2/">github博客</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/go/">go</a><span class="category-list-count">26</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/html-css/">html+css</a><span class="category-list-count">24</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iis/">iis</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">66</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/">javascript</a><span class="category-list-count">114</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/kotlin/">kotlin</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">68</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mac/">mac</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/memcached/">memcached</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mongodb/">mongodb</a><span class="category-list-count">19</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a><span class="category-list-count">72</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/">nginx</a><span class="category-list-count">41</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/nodejs/">nodejs</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/php/">php</a><span class="category-list-count">185</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a><span class="category-list-count">44</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%B6%E5%AE%83/">其它</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a><span class="category-list-count">51</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/">开源项目</a><span class="category-list-count">73</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/">生活随笔</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93/">量化交易</a><span class="category-list-count">3</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/AndroidStudio/" style="font-size: 13.75px;">AndroidStudio</a> <a href="/tags/AndroidUI/" style="font-size: 20px;">AndroidUI</a> <a href="/tags/Android%E4%BA%8B%E4%BB%B6%E6%8B%A6%E6%88%AA/" style="font-size: 11.25px;">Android事件拦截</a> <a href="/tags/Android%E5%BC%80%E6%BA%90/" style="font-size: 18.13px;">Android开源</a> <a href="/tags/CI/" style="font-size: 15.63px;">CI</a> <a href="/tags/CURL/" style="font-size: 13.13px;">CURL</a> <a href="/tags/DEDE/" style="font-size: 18.75px;">DEDE</a> <a href="/tags/Docker/" style="font-size: 15px;">Docker</a> <a href="/tags/Flask/" style="font-size: 10.63px;">Flask</a> <a href="/tags/JavaSE/" style="font-size: 18.13px;">JavaSE</a> <a href="/tags/Laravel/" style="font-size: 18.13px;">Laravel</a> <a href="/tags/Maven/" style="font-size: 11.25px;">Maven</a> <a href="/tags/SVN/" style="font-size: 10px;">SVN</a> <a href="/tags/SpringBoot/" style="font-size: 19.38px;">SpringBoot</a> <a href="/tags/Thinkphp/" style="font-size: 10px;">Thinkphp</a> <a href="/tags/UEditor/" style="font-size: 11.88px;">UEditor</a> <a href="/tags/VMware/" style="font-size: 12.5px;">VMware</a> <a href="/tags/Vue/" style="font-size: 18.13px;">Vue</a> <a href="/tags/WebSocket/" style="font-size: 13.13px;">WebSocket</a> <a href="/tags/ecshop/" style="font-size: 15px;">ecshop</a> <a href="/tags/scrapy/" style="font-size: 14.38px;">scrapy</a> <a href="/tags/smarty/" style="font-size: 12.5px;">smarty</a> <a href="/tags/socket/" style="font-size: 15px;">socket</a> <a href="/tags/sphinx/" style="font-size: 11.88px;">sphinx</a> <a href="/tags/vagrant/" style="font-size: 12.5px;">vagrant</a> <a href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" style="font-size: 11.25px;">微服务</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/" style="font-size: 15.63px;">数据传输</a> <a href="/tags/%E6%AD%A3%E5%88%99/" style="font-size: 11.88px;">正则</a> <a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size: 16.25px;">消息队列</a> <a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size: 16.88px;">爬虫</a> <a href="/tags/%E9%9B%86%E7%BE%A4/" style="font-size: 17.5px;">集群</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/12/06/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9A%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%E7%BA%BF%E7%A8%8B%E6%B1%A0/">Java 多线程：彻底搞懂线程池</a>
          </li>
        
          <li>
            <a href="/2022/12/04/Autowired%E6%B3%A8%E8%A7%A3%E4%B8%8EResource%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8C%BA%E5%88%AB/">Autowired注解与Resource注解的区别</a>
          </li>
        
          <li>
            <a href="/2022/11/29/Maven%E5%A4%9A%E6%A8%A1%E5%9D%97%E9%A1%B9%E7%9B%AE%E5%AE%9E%E7%8E%B0%E5%85%B1%E7%94%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/">Maven多模块项目实现共用配置文件</a>
          </li>
        
          <li>
            <a href="/2022/11/27/Java%E6%95%99%E7%A8%8B%E7%B4%A2%E5%BC%95/">Java教程索引</a>
          </li>
        
          <li>
            <a href="/2022/11/23/Spring-Boot-Event-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%8C%E8%BD%BB%E6%9D%BE%E5%AE%9E%E7%8E%B0%E4%B8%9A%E5%8A%A1%E8%A7%A3%E8%80%A6/">SpringBoot Event 观察者模式，轻松实现业务解耦</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 moqiang<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>

<!-- rex -->

<script src="/js/toc.js"></script>


  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>